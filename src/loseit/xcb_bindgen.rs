/* automatically generated by rust-bindgen 0.63.0 */

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const X_TCP_PORT: u32 = 6000;
pub const XCB_CONN_ERROR: u32 = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: u32 = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: u32 = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: u32 = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: u32 = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: u32 = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: u32 = 7;
pub const XCB_KEY_PRESS: u32 = 2;
pub const XCB_KEY_RELEASE: u32 = 3;
pub const XCB_BUTTON_PRESS: u32 = 4;
pub const XCB_BUTTON_RELEASE: u32 = 5;
pub const XCB_MOTION_NOTIFY: u32 = 6;
pub const XCB_ENTER_NOTIFY: u32 = 7;
pub const XCB_LEAVE_NOTIFY: u32 = 8;
pub const XCB_FOCUS_IN: u32 = 9;
pub const XCB_FOCUS_OUT: u32 = 10;
pub const XCB_KEYMAP_NOTIFY: u32 = 11;
pub const XCB_EXPOSE: u32 = 12;
pub const XCB_GRAPHICS_EXPOSURE: u32 = 13;
pub const XCB_NO_EXPOSURE: u32 = 14;
pub const XCB_VISIBILITY_NOTIFY: u32 = 15;
pub const XCB_CREATE_NOTIFY: u32 = 16;
pub const XCB_DESTROY_NOTIFY: u32 = 17;
pub const XCB_UNMAP_NOTIFY: u32 = 18;
pub const XCB_MAP_NOTIFY: u32 = 19;
pub const XCB_MAP_REQUEST: u32 = 20;
pub const XCB_REPARENT_NOTIFY: u32 = 21;
pub const XCB_CONFIGURE_NOTIFY: u32 = 22;
pub const XCB_CONFIGURE_REQUEST: u32 = 23;
pub const XCB_GRAVITY_NOTIFY: u32 = 24;
pub const XCB_RESIZE_REQUEST: u32 = 25;
pub const XCB_CIRCULATE_NOTIFY: u32 = 26;
pub const XCB_CIRCULATE_REQUEST: u32 = 27;
pub const XCB_PROPERTY_NOTIFY: u32 = 28;
pub const XCB_SELECTION_CLEAR: u32 = 29;
pub const XCB_SELECTION_REQUEST: u32 = 30;
pub const XCB_SELECTION_NOTIFY: u32 = 31;
pub const XCB_COLORMAP_NOTIFY: u32 = 32;
pub const XCB_CLIENT_MESSAGE: u32 = 33;
pub const XCB_MAPPING_NOTIFY: u32 = 34;
pub const XCB_GE_GENERIC: u32 = 35;
pub const XCB_REQUEST: u32 = 1;
pub const XCB_VALUE: u32 = 2;
pub const XCB_WINDOW: u32 = 3;
pub const XCB_PIXMAP: u32 = 4;
pub const XCB_ATOM: u32 = 5;
pub const XCB_CURSOR: u32 = 6;
pub const XCB_FONT: u32 = 7;
pub const XCB_MATCH: u32 = 8;
pub const XCB_DRAWABLE: u32 = 9;
pub const XCB_ACCESS: u32 = 10;
pub const XCB_ALLOC: u32 = 11;
pub const XCB_COLORMAP: u32 = 12;
pub const XCB_G_CONTEXT: u32 = 13;
pub const XCB_ID_CHOICE: u32 = 14;
pub const XCB_NAME: u32 = 15;
pub const XCB_LENGTH: u32 = 16;
pub const XCB_IMPLEMENTATION: u32 = 17;
pub const XCB_CREATE_WINDOW: u32 = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: u32 = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: u32 = 3;
pub const XCB_DESTROY_WINDOW: u32 = 4;
pub const XCB_DESTROY_SUBWINDOWS: u32 = 5;
pub const XCB_CHANGE_SAVE_SET: u32 = 6;
pub const XCB_REPARENT_WINDOW: u32 = 7;
pub const XCB_MAP_WINDOW: u32 = 8;
pub const XCB_MAP_SUBWINDOWS: u32 = 9;
pub const XCB_UNMAP_WINDOW: u32 = 10;
pub const XCB_UNMAP_SUBWINDOWS: u32 = 11;
pub const XCB_CONFIGURE_WINDOW: u32 = 12;
pub const XCB_CIRCULATE_WINDOW: u32 = 13;
pub const XCB_GET_GEOMETRY: u32 = 14;
pub const XCB_QUERY_TREE: u32 = 15;
pub const XCB_INTERN_ATOM: u32 = 16;
pub const XCB_GET_ATOM_NAME: u32 = 17;
pub const XCB_CHANGE_PROPERTY: u32 = 18;
pub const XCB_DELETE_PROPERTY: u32 = 19;
pub const XCB_GET_PROPERTY: u32 = 20;
pub const XCB_LIST_PROPERTIES: u32 = 21;
pub const XCB_SET_SELECTION_OWNER: u32 = 22;
pub const XCB_GET_SELECTION_OWNER: u32 = 23;
pub const XCB_CONVERT_SELECTION: u32 = 24;
pub const XCB_SEND_EVENT: u32 = 25;
pub const XCB_GRAB_POINTER: u32 = 26;
pub const XCB_UNGRAB_POINTER: u32 = 27;
pub const XCB_GRAB_BUTTON: u32 = 28;
pub const XCB_UNGRAB_BUTTON: u32 = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: u32 = 30;
pub const XCB_GRAB_KEYBOARD: u32 = 31;
pub const XCB_UNGRAB_KEYBOARD: u32 = 32;
pub const XCB_GRAB_KEY: u32 = 33;
pub const XCB_UNGRAB_KEY: u32 = 34;
pub const XCB_ALLOW_EVENTS: u32 = 35;
pub const XCB_GRAB_SERVER: u32 = 36;
pub const XCB_UNGRAB_SERVER: u32 = 37;
pub const XCB_QUERY_POINTER: u32 = 38;
pub const XCB_GET_MOTION_EVENTS: u32 = 39;
pub const XCB_TRANSLATE_COORDINATES: u32 = 40;
pub const XCB_WARP_POINTER: u32 = 41;
pub const XCB_SET_INPUT_FOCUS: u32 = 42;
pub const XCB_GET_INPUT_FOCUS: u32 = 43;
pub const XCB_QUERY_KEYMAP: u32 = 44;
pub const XCB_OPEN_FONT: u32 = 45;
pub const XCB_CLOSE_FONT: u32 = 46;
pub const XCB_QUERY_FONT: u32 = 47;
pub const XCB_QUERY_TEXT_EXTENTS: u32 = 48;
pub const XCB_LIST_FONTS: u32 = 49;
pub const XCB_LIST_FONTS_WITH_INFO: u32 = 50;
pub const XCB_SET_FONT_PATH: u32 = 51;
pub const XCB_GET_FONT_PATH: u32 = 52;
pub const XCB_CREATE_PIXMAP: u32 = 53;
pub const XCB_FREE_PIXMAP: u32 = 54;
pub const XCB_CREATE_GC: u32 = 55;
pub const XCB_CHANGE_GC: u32 = 56;
pub const XCB_COPY_GC: u32 = 57;
pub const XCB_SET_DASHES: u32 = 58;
pub const XCB_SET_CLIP_RECTANGLES: u32 = 59;
pub const XCB_FREE_GC: u32 = 60;
pub const XCB_CLEAR_AREA: u32 = 61;
pub const XCB_COPY_AREA: u32 = 62;
pub const XCB_COPY_PLANE: u32 = 63;
pub const XCB_POLY_POINT: u32 = 64;
pub const XCB_POLY_LINE: u32 = 65;
pub const XCB_POLY_SEGMENT: u32 = 66;
pub const XCB_POLY_RECTANGLE: u32 = 67;
pub const XCB_POLY_ARC: u32 = 68;
pub const XCB_FILL_POLY: u32 = 69;
pub const XCB_POLY_FILL_RECTANGLE: u32 = 70;
pub const XCB_POLY_FILL_ARC: u32 = 71;
pub const XCB_PUT_IMAGE: u32 = 72;
pub const XCB_GET_IMAGE: u32 = 73;
pub const XCB_POLY_TEXT_8: u32 = 74;
pub const XCB_POLY_TEXT_16: u32 = 75;
pub const XCB_IMAGE_TEXT_8: u32 = 76;
pub const XCB_IMAGE_TEXT_16: u32 = 77;
pub const XCB_CREATE_COLORMAP: u32 = 78;
pub const XCB_FREE_COLORMAP: u32 = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: u32 = 80;
pub const XCB_INSTALL_COLORMAP: u32 = 81;
pub const XCB_UNINSTALL_COLORMAP: u32 = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: u32 = 83;
pub const XCB_ALLOC_COLOR: u32 = 84;
pub const XCB_ALLOC_NAMED_COLOR: u32 = 85;
pub const XCB_ALLOC_COLOR_CELLS: u32 = 86;
pub const XCB_ALLOC_COLOR_PLANES: u32 = 87;
pub const XCB_FREE_COLORS: u32 = 88;
pub const XCB_STORE_COLORS: u32 = 89;
pub const XCB_STORE_NAMED_COLOR: u32 = 90;
pub const XCB_QUERY_COLORS: u32 = 91;
pub const XCB_LOOKUP_COLOR: u32 = 92;
pub const XCB_CREATE_CURSOR: u32 = 93;
pub const XCB_CREATE_GLYPH_CURSOR: u32 = 94;
pub const XCB_FREE_CURSOR: u32 = 95;
pub const XCB_RECOLOR_CURSOR: u32 = 96;
pub const XCB_QUERY_BEST_SIZE: u32 = 97;
pub const XCB_QUERY_EXTENSION: u32 = 98;
pub const XCB_LIST_EXTENSIONS: u32 = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: u32 = 100;
pub const XCB_GET_KEYBOARD_MAPPING: u32 = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: u32 = 102;
pub const XCB_GET_KEYBOARD_CONTROL: u32 = 103;
pub const XCB_BELL: u32 = 104;
pub const XCB_CHANGE_POINTER_CONTROL: u32 = 105;
pub const XCB_GET_POINTER_CONTROL: u32 = 106;
pub const XCB_SET_SCREEN_SAVER: u32 = 107;
pub const XCB_GET_SCREEN_SAVER: u32 = 108;
pub const XCB_CHANGE_HOSTS: u32 = 109;
pub const XCB_LIST_HOSTS: u32 = 110;
pub const XCB_SET_ACCESS_CONTROL: u32 = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: u32 = 112;
pub const XCB_KILL_CLIENT: u32 = 113;
pub const XCB_ROTATE_PROPERTIES: u32 = 114;
pub const XCB_FORCE_SCREEN_SAVER: u32 = 115;
pub const XCB_SET_POINTER_MAPPING: u32 = 116;
pub const XCB_GET_POINTER_MAPPING: u32 = 117;
pub const XCB_SET_MODIFIER_MAPPING: u32 = 118;
pub const XCB_GET_MODIFIER_MAPPING: u32 = 119;
pub const XCB_NO_OPERATION: u32 = 127;
pub const XCB_NONE: u32 = 0;
pub const XCB_COPY_FROM_PARENT: u32 = 0;
pub const XCB_CURRENT_TIME: u32 = 0;
pub const XCB_NO_SYMBOL: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t {
    _unused: [u8; 0],
}
#[doc = " @brief Generic iterator.\n\n A generic iterator structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_iterator_t {
    #[doc = "< Data of the current iterator"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< remaining elements"]
    pub rem: ::std::os::raw::c_int,
    #[doc = "< index of the current iterator"]
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_generic_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_generic_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief Generic reply.\n\n A generic reply structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_reply_t {
    #[doc = "< Type of the response"]
    pub response_type: u8,
    #[doc = "< Padding"]
    pub pad0: u8,
    #[doc = "< Sequence number"]
    pub sequence: u16,
    #[doc = "< Length of the response"]
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_generic_reply_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief Generic event.\n\n A generic event structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_event_t {
    #[doc = "< Type of the response"]
    pub response_type: u8,
    #[doc = "< Padding"]
    pub pad0: u8,
    #[doc = "< Sequence number"]
    pub sequence: u16,
    #[doc = "< Padding"]
    pub pad: [u32; 7usize],
    #[doc = "< full sequence"]
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_generic_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_sequence) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[doc = " @brief Raw Generic event.\n\n A generic event structure as used on the wire, i.e., without the full_sequence field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_raw_generic_event_t {
    #[doc = "< Type of the response"]
    pub response_type: u8,
    #[doc = "< Padding"]
    pub pad0: u8,
    #[doc = "< Sequence number"]
    pub sequence: u16,
    #[doc = "< Padding"]
    pub pad: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_xcb_raw_generic_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_raw_generic_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_raw_generic_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_raw_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
}
#[doc = " @brief GE event\n\n An event as sent by the XGE extension. The length field specifies the\n number of 4-byte blocks trailing the struct.\n\n @deprecated Since some fields in this struct have unfortunate names, it is\n recommended to use xcb_ge_generic_event_t instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_event_t {
    #[doc = "< Type of the response"]
    pub response_type: u8,
    #[doc = "< Padding"]
    pub pad0: u8,
    #[doc = "< Sequence number"]
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    #[doc = "< Padding"]
    pub pad: [u32; 5usize],
    #[doc = "< full sequence"]
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ge_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_sequence) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[doc = " @brief Generic error.\n\n A generic error structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_error_t {
    #[doc = "< Type of the response"]
    pub response_type: u8,
    #[doc = "< Error code"]
    pub error_code: u8,
    #[doc = "< Sequence number"]
    pub sequence: u16,
    pub resource_id: u32,
    #[doc = " < Resource ID for requests with side effects only"]
    pub minor_code: u16,
    #[doc = " < Minor opcode of the failed request"]
    pub major_code: u8,
    #[doc = " < Major opcode of the failed request"]
    pub pad0: u8,
    #[doc = "< Padding"]
    pub pad: [u32; 5usize],
    #[doc = "< full sequence"]
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_error_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_generic_error_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_error_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(resource_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(minor_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_code) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_sequence) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[doc = " @brief Generic cookie.\n\n A generic cookie structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_void_cookie_t {
    #[doc = "< Sequence number"]
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_void_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_void_cookie_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_void_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_char2b_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_char2b_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_t>(),
        2usize,
        concat!("Size of: ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte2) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte2)
        )
    );
}
#[doc = " @brief xcb_char2b_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_char2b_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_window_t = u32;
#[doc = " @brief xcb_window_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_window_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_window_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_window_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_pixmap_t = u32;
#[doc = " @brief xcb_pixmap_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_pixmap_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_pixmap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_pixmap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_cursor_t = u32;
#[doc = " @brief xcb_cursor_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_cursor_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_cursor_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_cursor_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_font_t = u32;
#[doc = " @brief xcb_font_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_font_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_font_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_font_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_gcontext_t = u32;
#[doc = " @brief xcb_gcontext_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_gcontext_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_gcontext_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gcontext_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_colormap_t = u32;
#[doc = " @brief xcb_colormap_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_colormap_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_atom_t = u32;
#[doc = " @brief xcb_atom_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_atom_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_atom_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_atom_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_drawable_t = u32;
#[doc = " @brief xcb_drawable_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_drawable_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_drawable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_drawable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_fontable_t = u32;
#[doc = " @brief xcb_fontable_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_fontable_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_fontable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_bool32_t = u32;
#[doc = " @brief xcb_bool32_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_bool32_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_bool32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bool32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_visualid_t = u32;
#[doc = " @brief xcb_visualid_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_visualid_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_visualid_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualid_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_timestamp_t = u32;
#[doc = " @brief xcb_timestamp_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_timestamp_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_timestamp_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timestamp_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keysym_t = u32;
#[doc = " @brief xcb_keysym_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_keysym_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_keysym_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keysym_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode_t = u8;
#[doc = " @brief xcb_keycode_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_keycode_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode32_t = u32;
#[doc = " @brief xcb_keycode32_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_keycode32_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_button_t = u8;
#[doc = " @brief xcb_button_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_button_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_button_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_point_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_point_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_point_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_point_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_point_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_point_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_point_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_rectangle_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_rectangle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_rectangle_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_rectangle_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_arc_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_arc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle2)
        )
    );
}
#[doc = " @brief xcb_arc_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_arc_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_format_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_format_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_format_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_format_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scanline_pad) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(scanline_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_format_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_format_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_format_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_GRAY: xcb_visual_class_t = 0;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_GRAY_SCALE: xcb_visual_class_t = 1;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_COLOR: xcb_visual_class_t = 2;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_PSEUDO_COLOR: xcb_visual_class_t = 3;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_TRUE_COLOR: xcb_visual_class_t = 4;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_DIRECT_COLOR: xcb_visual_class_t = 5;
pub type xcb_visual_class_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_visualtype_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_visualtype_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(visual_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_rgb_value) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(bits_per_rgb_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colormap_entries) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(colormap_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_visualtype_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_visualtype_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_depth_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_depth_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visuals_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(visuals_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_depth_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_depth_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_event_mask_t_XCB_EVENT_MASK_NO_EVENT: xcb_event_mask_t = 0;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_PRESS: xcb_event_mask_t = 1;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_RELEASE: xcb_event_mask_t = 2;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_PRESS: xcb_event_mask_t = 4;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_RELEASE: xcb_event_mask_t = 8;
pub const xcb_event_mask_t_XCB_EVENT_MASK_ENTER_WINDOW: xcb_event_mask_t = 16;
pub const xcb_event_mask_t_XCB_EVENT_MASK_LEAVE_WINDOW: xcb_event_mask_t = 32;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION: xcb_event_mask_t = 64;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION_HINT: xcb_event_mask_t = 128;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_1_MOTION: xcb_event_mask_t = 256;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_2_MOTION: xcb_event_mask_t = 512;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_3_MOTION: xcb_event_mask_t = 1024;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_4_MOTION: xcb_event_mask_t = 2048;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_5_MOTION: xcb_event_mask_t = 4096;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_MOTION: xcb_event_mask_t = 8192;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEYMAP_STATE: xcb_event_mask_t = 16384;
pub const xcb_event_mask_t_XCB_EVENT_MASK_EXPOSURE: xcb_event_mask_t = 32768;
pub const xcb_event_mask_t_XCB_EVENT_MASK_VISIBILITY_CHANGE: xcb_event_mask_t = 65536;
pub const xcb_event_mask_t_XCB_EVENT_MASK_STRUCTURE_NOTIFY: xcb_event_mask_t = 131072;
pub const xcb_event_mask_t_XCB_EVENT_MASK_RESIZE_REDIRECT: xcb_event_mask_t = 262144;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY: xcb_event_mask_t = 524288;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT: xcb_event_mask_t = 1048576;
pub const xcb_event_mask_t_XCB_EVENT_MASK_FOCUS_CHANGE: xcb_event_mask_t = 2097152;
pub const xcb_event_mask_t_XCB_EVENT_MASK_PROPERTY_CHANGE: xcb_event_mask_t = 4194304;
pub const xcb_event_mask_t_XCB_EVENT_MASK_COLOR_MAP_CHANGE: xcb_event_mask_t = 8388608;
pub const xcb_event_mask_t_XCB_EVENT_MASK_OWNER_GRAB_BUTTON: xcb_event_mask_t = 16777216;
pub type xcb_event_mask_t = ::std::os::raw::c_uint;
pub const xcb_backing_store_t_XCB_BACKING_STORE_NOT_USEFUL: xcb_backing_store_t = 0;
pub const xcb_backing_store_t_XCB_BACKING_STORE_WHEN_MAPPED: xcb_backing_store_t = 1;
pub const xcb_backing_store_t_XCB_BACKING_STORE_ALWAYS: xcb_backing_store_t = 2;
pub type xcb_backing_store_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_screen_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_screen_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_colormap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(default_colormap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_pixel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_pixel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_input_masks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(current_input_masks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_in_pixels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height_in_pixels) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_pixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_in_millimeters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_millimeters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height_in_millimeters) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_millimeters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_installed_maps) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(min_installed_maps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_installed_maps) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(max_installed_maps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_visual) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_stores) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(backing_stores)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_unders) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_depth) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_depths_len) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(allowed_depths_len)
        )
    );
}
#[doc = " @brief xcb_screen_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_screen_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_setup_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_request_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_major_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_minor_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).authorization_protocol_name_len) as usize - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_name_len)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).authorization_protocol_data_len) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_setup_request_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_request_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_setup_failed_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_failed_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(reason_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_major_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_minor_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_setup_failed_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_failed_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_setup_authenticate_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_authenticate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_setup_authenticate_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_authenticate_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_setup_authenticate_iterator_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_image_order_t_XCB_IMAGE_ORDER_LSB_FIRST: xcb_image_order_t = 0;
pub const xcb_image_order_t_XCB_IMAGE_ORDER_MSB_FIRST: xcb_image_order_t = 1;
pub type xcb_image_order_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_setup_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_major_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_minor_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_id_base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_id_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motion_buffer_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(motion_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(vendor_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum_request_length) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(maximum_request_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roots_len) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(roots_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixmap_formats_len) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pixmap_formats_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_byte_order) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(image_byte_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_format_bit_order) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_bit_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_format_scanline_unit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_format_scanline_pad) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_keycode) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_keycode) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_setup_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_setup_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_mod_mask_t_XCB_MOD_MASK_SHIFT: xcb_mod_mask_t = 1;
pub const xcb_mod_mask_t_XCB_MOD_MASK_LOCK: xcb_mod_mask_t = 2;
pub const xcb_mod_mask_t_XCB_MOD_MASK_CONTROL: xcb_mod_mask_t = 4;
pub const xcb_mod_mask_t_XCB_MOD_MASK_1: xcb_mod_mask_t = 8;
pub const xcb_mod_mask_t_XCB_MOD_MASK_2: xcb_mod_mask_t = 16;
pub const xcb_mod_mask_t_XCB_MOD_MASK_3: xcb_mod_mask_t = 32;
pub const xcb_mod_mask_t_XCB_MOD_MASK_4: xcb_mod_mask_t = 64;
pub const xcb_mod_mask_t_XCB_MOD_MASK_5: xcb_mod_mask_t = 128;
pub const xcb_mod_mask_t_XCB_MOD_MASK_ANY: xcb_mod_mask_t = 32768;
pub type xcb_mod_mask_t = ::std::os::raw::c_uint;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_SHIFT: xcb_key_but_mask_t = 1;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_LOCK: xcb_key_but_mask_t = 2;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_CONTROL: xcb_key_but_mask_t = 4;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_1: xcb_key_but_mask_t = 8;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_2: xcb_key_but_mask_t = 16;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_3: xcb_key_but_mask_t = 32;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_4: xcb_key_but_mask_t = 64;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_5: xcb_key_but_mask_t = 128;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_1: xcb_key_but_mask_t = 256;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_2: xcb_key_but_mask_t = 512;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_3: xcb_key_but_mask_t = 1024;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_4: xcb_key_but_mask_t = 2048;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_5: xcb_key_but_mask_t = 4096;
pub type xcb_key_but_mask_t = ::std::os::raw::c_uint;
pub const xcb_window_enum_t_XCB_WINDOW_NONE: xcb_window_enum_t = 0;
pub type xcb_window_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_key_press_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_key_press_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_key_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_key_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_y) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_key_press_event_t"]
pub type xcb_key_release_event_t = xcb_key_press_event_t;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_1: xcb_button_mask_t = 256;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_2: xcb_button_mask_t = 512;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_3: xcb_button_mask_t = 1024;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_4: xcb_button_mask_t = 2048;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_5: xcb_button_mask_t = 4096;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_ANY: xcb_button_mask_t = 32768;
pub type xcb_button_mask_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_button_press_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_button_press_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_button_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_y) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_button_press_event_t"]
pub type xcb_button_release_event_t = xcb_button_press_event_t;
pub const xcb_motion_t_XCB_MOTION_NORMAL: xcb_motion_t = 0;
pub const xcb_motion_t_XCB_MOTION_HINT: xcb_motion_t = 1;
pub type xcb_motion_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_motion_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_motion_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_motion_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_motion_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_y) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_ANCESTOR: xcb_notify_detail_t = 0;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_VIRTUAL: xcb_notify_detail_t = 1;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_INFERIOR: xcb_notify_detail_t = 2;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR: xcb_notify_detail_t = 3;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL: xcb_notify_detail_t = 4;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER: xcb_notify_detail_t = 5;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER_ROOT: xcb_notify_detail_t = 6;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONE: xcb_notify_detail_t = 7;
pub type xcb_notify_detail_t = ::std::os::raw::c_uint;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_NORMAL: xcb_notify_mode_t = 0;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_GRAB: xcb_notify_mode_t = 1;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_UNGRAB: xcb_notify_mode_t = 2;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_WHILE_GRABBED: xcb_notify_mode_t = 3;
pub type xcb_notify_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_enter_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_enter_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_enter_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_enter_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_y) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen_focus) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(same_screen_focus)
        )
    );
}
#[doc = " @brief xcb_enter_notify_event_t"]
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[doc = " @brief xcb_focus_in_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_focus_in_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_focus_in_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_focus_in_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_focus_in_event_t"]
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[doc = " @brief xcb_keymap_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_keymap_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_keymap_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keymap_notify_event_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief xcb_expose_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_expose_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_expose_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_expose_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_graphics_exposure_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_graphics_exposure_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_graphics_exposure_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_graphics_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_opcode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_no_exposure_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_no_exposure_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_no_exposure_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_opcode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_visibility_t_XCB_VISIBILITY_UNOBSCURED: xcb_visibility_t = 0;
pub const xcb_visibility_t_XCB_VISIBILITY_PARTIALLY_OBSCURED: xcb_visibility_t = 1;
pub const xcb_visibility_t_XCB_VISIBILITY_FULLY_OBSCURED: xcb_visibility_t = 2;
pub type xcb_visibility_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_visibility_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_visibility_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_visibility_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visibility_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_create_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_destroy_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_destroy_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_unmap_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_unmap_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_configure) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(from_configure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_map_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_map_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_map_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_map_request_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_map_request_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_map_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_reparent_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_reparent_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_configure_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_configure_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_notify_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).above_sibling) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(above_sibling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_configure_request_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_configure_request_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(stack_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_gravity_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_gravity_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_gravity_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gravity_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_resize_request_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_resize_request_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_resize_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_resize_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(height)
        )
    );
}
pub const xcb_place_t_XCB_PLACE_ON_TOP: xcb_place_t = 0;
pub const xcb_place_t_XCB_PLACE_ON_BOTTOM: xcb_place_t = 1;
pub type xcb_place_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_circulate_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_circulate_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).place) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(place)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad2)
        )
    );
}
#[doc = " @brief xcb_circulate_notify_event_t"]
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
pub const xcb_property_t_XCB_PROPERTY_NEW_VALUE: xcb_property_t = 0;
pub const xcb_property_t_XCB_PROPERTY_DELETE: xcb_property_t = 1;
pub type xcb_property_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_property_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_property_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_property_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_property_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_selection_clear_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_selection_clear_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_clear_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_clear_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(selection)
        )
    );
}
pub const xcb_time_t_XCB_TIME_CURRENT_TIME: xcb_time_t = 0;
pub type xcb_time_t = ::std::os::raw::c_uint;
pub const xcb_atom_enum_t_XCB_ATOM_NONE: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_PRIMARY: xcb_atom_enum_t = 1;
pub const xcb_atom_enum_t_XCB_ATOM_SECONDARY: xcb_atom_enum_t = 2;
pub const xcb_atom_enum_t_XCB_ATOM_ARC: xcb_atom_enum_t = 3;
pub const xcb_atom_enum_t_XCB_ATOM_ATOM: xcb_atom_enum_t = 4;
pub const xcb_atom_enum_t_XCB_ATOM_BITMAP: xcb_atom_enum_t = 5;
pub const xcb_atom_enum_t_XCB_ATOM_CARDINAL: xcb_atom_enum_t = 6;
pub const xcb_atom_enum_t_XCB_ATOM_COLORMAP: xcb_atom_enum_t = 7;
pub const xcb_atom_enum_t_XCB_ATOM_CURSOR: xcb_atom_enum_t = 8;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER0: xcb_atom_enum_t = 9;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER1: xcb_atom_enum_t = 10;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER2: xcb_atom_enum_t = 11;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER3: xcb_atom_enum_t = 12;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER4: xcb_atom_enum_t = 13;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER5: xcb_atom_enum_t = 14;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER6: xcb_atom_enum_t = 15;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER7: xcb_atom_enum_t = 16;
pub const xcb_atom_enum_t_XCB_ATOM_DRAWABLE: xcb_atom_enum_t = 17;
pub const xcb_atom_enum_t_XCB_ATOM_FONT: xcb_atom_enum_t = 18;
pub const xcb_atom_enum_t_XCB_ATOM_INTEGER: xcb_atom_enum_t = 19;
pub const xcb_atom_enum_t_XCB_ATOM_PIXMAP: xcb_atom_enum_t = 20;
pub const xcb_atom_enum_t_XCB_ATOM_POINT: xcb_atom_enum_t = 21;
pub const xcb_atom_enum_t_XCB_ATOM_RECTANGLE: xcb_atom_enum_t = 22;
pub const xcb_atom_enum_t_XCB_ATOM_RESOURCE_MANAGER: xcb_atom_enum_t = 23;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_COLOR_MAP: xcb_atom_enum_t = 24;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BEST_MAP: xcb_atom_enum_t = 25;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BLUE_MAP: xcb_atom_enum_t = 26;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_DEFAULT_MAP: xcb_atom_enum_t = 27;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GRAY_MAP: xcb_atom_enum_t = 28;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GREEN_MAP: xcb_atom_enum_t = 29;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_RED_MAP: xcb_atom_enum_t = 30;
pub const xcb_atom_enum_t_XCB_ATOM_STRING: xcb_atom_enum_t = 31;
pub const xcb_atom_enum_t_XCB_ATOM_VISUALID: xcb_atom_enum_t = 32;
pub const xcb_atom_enum_t_XCB_ATOM_WINDOW: xcb_atom_enum_t = 33;
pub const xcb_atom_enum_t_XCB_ATOM_WM_COMMAND: xcb_atom_enum_t = 34;
pub const xcb_atom_enum_t_XCB_ATOM_WM_HINTS: xcb_atom_enum_t = 35;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLIENT_MACHINE: xcb_atom_enum_t = 36;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_NAME: xcb_atom_enum_t = 37;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_SIZE: xcb_atom_enum_t = 38;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NAME: xcb_atom_enum_t = 39;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NORMAL_HINTS: xcb_atom_enum_t = 40;
pub const xcb_atom_enum_t_XCB_ATOM_WM_SIZE_HINTS: xcb_atom_enum_t = 41;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ZOOM_HINTS: xcb_atom_enum_t = 42;
pub const xcb_atom_enum_t_XCB_ATOM_MIN_SPACE: xcb_atom_enum_t = 43;
pub const xcb_atom_enum_t_XCB_ATOM_NORM_SPACE: xcb_atom_enum_t = 44;
pub const xcb_atom_enum_t_XCB_ATOM_MAX_SPACE: xcb_atom_enum_t = 45;
pub const xcb_atom_enum_t_XCB_ATOM_END_SPACE: xcb_atom_enum_t = 46;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_X: xcb_atom_enum_t = 47;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_Y: xcb_atom_enum_t = 48;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_X: xcb_atom_enum_t = 49;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_Y: xcb_atom_enum_t = 50;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_POSITION: xcb_atom_enum_t = 51;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_THICKNESS: xcb_atom_enum_t = 52;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_ASCENT: xcb_atom_enum_t = 53;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_DESCENT: xcb_atom_enum_t = 54;
pub const xcb_atom_enum_t_XCB_ATOM_ITALIC_ANGLE: xcb_atom_enum_t = 55;
pub const xcb_atom_enum_t_XCB_ATOM_X_HEIGHT: xcb_atom_enum_t = 56;
pub const xcb_atom_enum_t_XCB_ATOM_QUAD_WIDTH: xcb_atom_enum_t = 57;
pub const xcb_atom_enum_t_XCB_ATOM_WEIGHT: xcb_atom_enum_t = 58;
pub const xcb_atom_enum_t_XCB_ATOM_POINT_SIZE: xcb_atom_enum_t = 59;
pub const xcb_atom_enum_t_XCB_ATOM_RESOLUTION: xcb_atom_enum_t = 60;
pub const xcb_atom_enum_t_XCB_ATOM_COPYRIGHT: xcb_atom_enum_t = 61;
pub const xcb_atom_enum_t_XCB_ATOM_NOTICE: xcb_atom_enum_t = 62;
pub const xcb_atom_enum_t_XCB_ATOM_FONT_NAME: xcb_atom_enum_t = 63;
pub const xcb_atom_enum_t_XCB_ATOM_FAMILY_NAME: xcb_atom_enum_t = 64;
pub const xcb_atom_enum_t_XCB_ATOM_FULL_NAME: xcb_atom_enum_t = 65;
pub const xcb_atom_enum_t_XCB_ATOM_CAP_HEIGHT: xcb_atom_enum_t = 66;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLASS: xcb_atom_enum_t = 67;
pub const xcb_atom_enum_t_XCB_ATOM_WM_TRANSIENT_FOR: xcb_atom_enum_t = 68;
pub type xcb_atom_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_selection_request_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_selection_request_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(property)
        )
    );
}
#[doc = " @brief xcb_selection_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_selection_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_UNINSTALLED: xcb_colormap_state_t = 0;
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_INSTALLED: xcb_colormap_state_t = 1;
pub type xcb_colormap_state_t = ::std::os::raw::c_uint;
pub const xcb_colormap_enum_t_XCB_COLORMAP_NONE: xcb_colormap_enum_t = 0;
pub type xcb_colormap_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_colormap_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_colormap_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_client_message_data_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union xcb_client_message_data_t {
    pub data8: [u8; 20usize],
    pub data16: [u16; 10usize],
    pub data32: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_client_message_data_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data32)
        )
    );
}
#[doc = " @brief xcb_client_message_data_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_client_message_data_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_client_message_data_iterator_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_client_message_event_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_client_message_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(data)
        )
    );
}
pub const xcb_mapping_t_XCB_MAPPING_MODIFIER: xcb_mapping_t = 0;
pub const xcb_mapping_t_XCB_MAPPING_KEYBOARD: xcb_mapping_t = 1;
pub const xcb_mapping_t_XCB_MAPPING_POINTER: xcb_mapping_t = 2;
pub type xcb_mapping_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_mapping_notify_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_mapping_notify_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_mapping_notify_event_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_mapping_notify_event_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_keycode) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_ge_generic_event_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ge_generic_event_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_sequence) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[doc = " @brief xcb_request_error_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_request_error_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_request_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_request_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bad_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_opcode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_value_error_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_value_error_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_value_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_value_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bad_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_opcode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_value_error_t"]
pub type xcb_window_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_pixmap_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_atom_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_cursor_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_font_error_t = xcb_value_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_match_error_t = xcb_request_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_drawable_error_t = xcb_value_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_access_error_t = xcb_request_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_alloc_error_t = xcb_request_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_colormap_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_g_context_error_t = xcb_value_error_t;
#[doc = " @brief xcb_value_error_t"]
pub type xcb_id_choice_error_t = xcb_value_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_name_error_t = xcb_request_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_length_error_t = xcb_request_error_t;
#[doc = " @brief xcb_request_error_t"]
pub type xcb_implementation_error_t = xcb_request_error_t;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_COPY_FROM_PARENT: xcb_window_class_t = 0;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_OUTPUT: xcb_window_class_t = 1;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_ONLY: xcb_window_class_t = 2;
pub type xcb_window_class_t = ::std::os::raw::c_uint;
pub const xcb_cw_t_XCB_CW_BACK_PIXMAP: xcb_cw_t = 1;
pub const xcb_cw_t_XCB_CW_BACK_PIXEL: xcb_cw_t = 2;
pub const xcb_cw_t_XCB_CW_BORDER_PIXMAP: xcb_cw_t = 4;
pub const xcb_cw_t_XCB_CW_BORDER_PIXEL: xcb_cw_t = 8;
pub const xcb_cw_t_XCB_CW_BIT_GRAVITY: xcb_cw_t = 16;
pub const xcb_cw_t_XCB_CW_WIN_GRAVITY: xcb_cw_t = 32;
pub const xcb_cw_t_XCB_CW_BACKING_STORE: xcb_cw_t = 64;
pub const xcb_cw_t_XCB_CW_BACKING_PLANES: xcb_cw_t = 128;
pub const xcb_cw_t_XCB_CW_BACKING_PIXEL: xcb_cw_t = 256;
pub const xcb_cw_t_XCB_CW_OVERRIDE_REDIRECT: xcb_cw_t = 512;
pub const xcb_cw_t_XCB_CW_SAVE_UNDER: xcb_cw_t = 1024;
pub const xcb_cw_t_XCB_CW_EVENT_MASK: xcb_cw_t = 2048;
pub const xcb_cw_t_XCB_CW_DONT_PROPAGATE: xcb_cw_t = 4096;
pub const xcb_cw_t_XCB_CW_COLORMAP: xcb_cw_t = 8192;
pub const xcb_cw_t_XCB_CW_CURSOR: xcb_cw_t = 16384;
pub type xcb_cw_t = ::std::os::raw::c_uint;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_NONE: xcb_back_pixmap_t = 0;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_PARENT_RELATIVE: xcb_back_pixmap_t = 1;
pub type xcb_back_pixmap_t = ::std::os::raw::c_uint;
pub const xcb_gravity_t_XCB_GRAVITY_BIT_FORGET: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_WEST: xcb_gravity_t = 1;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH: xcb_gravity_t = 2;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_EAST: xcb_gravity_t = 3;
pub const xcb_gravity_t_XCB_GRAVITY_WEST: xcb_gravity_t = 4;
pub const xcb_gravity_t_XCB_GRAVITY_CENTER: xcb_gravity_t = 5;
pub const xcb_gravity_t_XCB_GRAVITY_EAST: xcb_gravity_t = 6;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_WEST: xcb_gravity_t = 7;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH: xcb_gravity_t = 8;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_EAST: xcb_gravity_t = 9;
pub const xcb_gravity_t_XCB_GRAVITY_STATIC: xcb_gravity_t = 10;
pub type xcb_gravity_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_create_window_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_window_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_value_list_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background_pixmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_pixmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_pixel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_gravity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win_gravity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_planes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_pixel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_under) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_not_propogate_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " @brief xcb_create_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(wid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_change_window_attributes_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_window_attributes_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_value_list_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background_pixmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_pixmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_pixel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_gravity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win_gravity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_planes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_pixel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_under) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_not_propogate_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " @brief xcb_change_window_attributes_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_window_attributes_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
pub const xcb_map_state_t_XCB_MAP_STATE_UNMAPPED: xcb_map_state_t = 0;
pub const xcb_map_state_t_XCB_MAP_STATE_UNVIEWABLE: xcb_map_state_t = 1;
pub const xcb_map_state_t_XCB_MAP_STATE_VIEWABLE: xcb_map_state_t = 2;
pub type xcb_map_state_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_get_window_attributes_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_window_attributes_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_window_attributes_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_window_attributes_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_get_window_attributes_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_window_attributes_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_reply_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_gravity) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win_gravity) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_planes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backing_pixel) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_under) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_is_installed) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_is_installed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_state) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_event_masks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).your_event_mask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_not_propagate_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_destroy_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_destroy_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_destroy_subwindows_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_destroy_subwindows_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_subwindows_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_destroy_subwindows_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_set_mode_t_XCB_SET_MODE_INSERT: xcb_set_mode_t = 0;
pub const xcb_set_mode_t_XCB_SET_MODE_DELETE: xcb_set_mode_t = 1;
pub type xcb_set_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_change_save_set_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_save_set_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_save_set_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_save_set_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_reparent_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_reparent_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_window_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_map_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_map_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_map_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_map_subwindows_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_map_subwindows_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_map_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_unmap_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_unmap_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_unmap_subwindows_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_unmap_subwindows_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_X: xcb_config_window_t = 1;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_Y: xcb_config_window_t = 2;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_WIDTH: xcb_config_window_t = 4;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_HEIGHT: xcb_config_window_t = 8;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_BORDER_WIDTH: xcb_config_window_t = 16;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_SIBLING: xcb_config_window_t = 32;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_STACK_MODE: xcb_config_window_t = 64;
pub type xcb_config_window_t = ::std::os::raw::c_uint;
pub const xcb_stack_mode_t_XCB_STACK_MODE_ABOVE: xcb_stack_mode_t = 0;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BELOW: xcb_stack_mode_t = 1;
pub const xcb_stack_mode_t_XCB_STACK_MODE_TOP_IF: xcb_stack_mode_t = 2;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BOTTOM_IF: xcb_stack_mode_t = 3;
pub const xcb_stack_mode_t_XCB_STACK_MODE_OPPOSITE: xcb_stack_mode_t = 4;
pub type xcb_stack_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_configure_window_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_configure_window_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_value_list_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_configure_window_value_list_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[doc = " @brief xcb_configure_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_configure_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_circulate_t_XCB_CIRCULATE_RAISE_LOWEST: xcb_circulate_t = 0;
pub const xcb_circulate_t_XCB_CIRCULATE_LOWER_HIGHEST: xcb_circulate_t = 1;
pub type xcb_circulate_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_circulate_window_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_circulate_window_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_get_geometry_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_geometry_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_geometry_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_geometry_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(drawable)
        )
    );
}
#[doc = " @brief xcb_get_geometry_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_geometry_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_query_tree_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_tree_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_tree_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_tree_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_query_tree_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_tree_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(children_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_intern_atom_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_intern_atom_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_intern_atom_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_intern_atom_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).only_if_exists) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(only_if_exists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_intern_atom_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_intern_atom_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(atom)
        )
    );
}
#[doc = " @brief xcb_get_atom_name_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_atom_name_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_atom_name_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_atom_name_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(atom)
        )
    );
}
#[doc = " @brief xcb_get_atom_name_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_atom_name_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_prop_mode_t_XCB_PROP_MODE_REPLACE: xcb_prop_mode_t = 0;
pub const xcb_prop_mode_t_XCB_PROP_MODE_PREPEND: xcb_prop_mode_t = 1;
pub const xcb_prop_mode_t_XCB_PROP_MODE_APPEND: xcb_prop_mode_t = 2;
pub type xcb_prop_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_change_property_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_property_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(data_len)
        )
    );
}
#[doc = " @brief xcb_delete_property_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_delete_property_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_delete_property_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_delete_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_get_property_type_t_XCB_GET_PROPERTY_TYPE_ANY: xcb_get_property_type_t = 0;
pub type xcb_get_property_type_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_get_property_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_property_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_property_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_property_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._delete) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_length)
        )
    );
}
#[doc = " @brief xcb_get_property_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_property_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_after) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(bytes_after)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_list_properties_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_properties_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_properties_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_properties_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_list_properties_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_properties_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atoms_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_set_selection_owner_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_selection_owner_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_selection_owner_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_set_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[doc = " @brief xcb_get_selection_owner_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_selection_owner_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_selection_owner_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_selection_owner_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
}
#[doc = " @brief xcb_get_selection_owner_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_selection_owner_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(owner)
        )
    );
}
#[doc = " @brief xcb_convert_selection_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_convert_selection_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_convert_selection_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_convert_selection_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_POINTER_WINDOW: xcb_send_event_dest_t = 0;
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_ITEM_FOCUS: xcb_send_event_dest_t = 1;
pub type xcb_send_event_dest_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_send_event_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_send_event_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_send_event_request_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_send_event_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propagate) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event)
        )
    );
}
pub const xcb_grab_mode_t_XCB_GRAB_MODE_SYNC: xcb_grab_mode_t = 0;
pub const xcb_grab_mode_t_XCB_GRAB_MODE_ASYNC: xcb_grab_mode_t = 1;
pub type xcb_grab_mode_t = ::std::os::raw::c_uint;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_SUCCESS: xcb_grab_status_t = 0;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_ALREADY_GRABBED: xcb_grab_status_t = 1;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_INVALID_TIME: xcb_grab_status_t = 2;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_NOT_VIEWABLE: xcb_grab_status_t = 3;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_FROZEN: xcb_grab_status_t = 4;
pub type xcb_grab_status_t = ::std::os::raw::c_uint;
pub const xcb_cursor_enum_t_XCB_CURSOR_NONE: xcb_cursor_enum_t = 0;
pub type xcb_cursor_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_grab_pointer_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_pointer_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_grab_pointer_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_pointer_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_events) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_mode) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_mode) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confine_to) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[doc = " @brief xcb_grab_pointer_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_pointer_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_ungrab_pointer_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ungrab_pointer_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_button_index_t_XCB_BUTTON_INDEX_ANY: xcb_button_index_t = 0;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_1: xcb_button_index_t = 1;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_2: xcb_button_index_t = 2;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_3: xcb_button_index_t = 3;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_4: xcb_button_index_t = 4;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_5: xcb_button_index_t = 5;
pub type xcb_button_index_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_grab_button_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_button_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_button_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_events) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_mode) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_mode) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confine_to) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
}
#[doc = " @brief xcb_ungrab_button_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ungrab_button_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_button_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_change_active_pointer_grab_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_active_pointer_grab_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_grab_keyboard_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_keyboard_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_grab_keyboard_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_keyboard_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_events) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_mode) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_grab_keyboard_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_keyboard_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_ungrab_keyboard_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ungrab_keyboard_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_keyboard_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_grab_t_XCB_GRAB_ANY: xcb_grab_t = 0;
pub type xcb_grab_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_grab_key_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_key_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_key_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_events) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_mode) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyboard_mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_ungrab_key_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ungrab_key_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_key_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grab_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_allow_t_XCB_ALLOW_ASYNC_POINTER: xcb_allow_t = 0;
pub const xcb_allow_t_XCB_ALLOW_SYNC_POINTER: xcb_allow_t = 1;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_POINTER: xcb_allow_t = 2;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_KEYBOARD: xcb_allow_t = 3;
pub const xcb_allow_t_XCB_ALLOW_SYNC_KEYBOARD: xcb_allow_t = 4;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_KEYBOARD: xcb_allow_t = 5;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_BOTH: xcb_allow_t = 6;
pub const xcb_allow_t_XCB_ALLOW_SYNC_BOTH: xcb_allow_t = 7;
pub type xcb_allow_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_allow_events_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_allow_events_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_allow_events_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_allow_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[doc = " @brief xcb_grab_server_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_grab_server_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_ungrab_server_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_ungrab_server_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_query_pointer_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_pointer_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_pointer_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_pointer_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_query_pointer_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_pointer_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_timecoord_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_timecoord_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_timecoord_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_timecoord_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_get_motion_events_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_motion_events_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_motion_events_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_motion_events_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(stop)
        )
    );
}
#[doc = " @brief xcb_get_motion_events_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_motion_events_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(events_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_translate_coordinates_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_translate_coordinates_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_translate_coordinates_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_translate_coordinates_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_y)
        )
    );
}
#[doc = " @brief xcb_translate_coordinates_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_translate_coordinates_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_reply_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_y)
        )
    );
}
#[doc = " @brief xcb_warp_pointer_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_warp_pointer_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_warp_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_warp_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_height) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_y)
        )
    );
}
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_NONE: xcb_input_focus_t = 0;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_POINTER_ROOT: xcb_input_focus_t = 1;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_PARENT: xcb_input_focus_t = 2;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_FOLLOW_KEYBOARD: xcb_input_focus_t = 3;
pub type xcb_input_focus_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_input_focus_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_input_focus_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_input_focus_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_input_focus_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revert_to) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[doc = " @brief xcb_get_input_focus_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_input_focus_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_input_focus_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_input_focus_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_input_focus_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_input_focus_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revert_to) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(focus)
        )
    );
}
#[doc = " @brief xcb_query_keymap_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_keymap_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_keymap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_keymap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_query_keymap_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_keymap_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_reply_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief xcb_open_font_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_open_font_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_open_font_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_open_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_close_font_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_close_font_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_close_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_close_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
pub const xcb_font_draw_t_XCB_FONT_DRAW_LEFT_TO_RIGHT: xcb_font_draw_t = 0;
pub const xcb_font_draw_t_XCB_FONT_DRAW_RIGHT_TO_LEFT: xcb_font_draw_t = 1;
pub type xcb_font_draw_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_fontprop_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_fontprop_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief xcb_fontprop_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_fontprop_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_charinfo_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_charinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left_side_bearing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(left_side_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right_side_bearing) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(right_side_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).character_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(character_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascent) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(attributes)
        )
    );
}
#[doc = " @brief xcb_charinfo_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_charinfo_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_query_font_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_font_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_font_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_font_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[doc = " @brief xcb_query_font_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_font_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_bounds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bounds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_char_or_byte2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_char_or_byte2) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_char) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties_len) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).draw_direction) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_byte1) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_byte1) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_chars_exist) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_ascent) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_descent) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).char_infos_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(char_infos_len)
        )
    );
}
#[doc = " @brief xcb_query_text_extents_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_text_extents_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_text_extents_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_text_extents_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_query_text_extents_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).odd_length) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(odd_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[doc = " @brief xcb_query_text_extents_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_text_extents_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).draw_direction) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_ascent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_descent) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overall_ascent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_ascent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overall_descent) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_descent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overall_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overall_left) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overall_right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_right)
        )
    );
}
#[doc = " @brief xcb_str_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_str_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_str_t>(),
        1usize,
        concat!("Size of: ", stringify!(xcb_str_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_str_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_t),
            "::",
            stringify!(name_len)
        )
    );
}
#[doc = " @brief xcb_str_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_str_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_str_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_list_fonts_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_fonts_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_names) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_len) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[doc = " @brief xcb_list_fonts_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_list_fonts_with_info_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_with_info_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_fonts_with_info_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_with_info_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_names) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_len) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[doc = " @brief xcb_list_fonts_with_info_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_fonts_with_info_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_bounds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bounds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_char_or_byte2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_char_or_byte2) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_char) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties_len) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).draw_direction) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_byte1) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_byte1) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_chars_exist) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_ascent) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_descent) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replies_hint) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(replies_hint)
        )
    );
}
#[doc = " @brief xcb_set_font_path_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_font_path_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_font_path_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_qty) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(font_qty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_get_font_path_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_font_path_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_font_path_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_font_path_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_font_path_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_font_path_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(path_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_create_pixmap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_pixmap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_pixmap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_free_pixmap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_free_pixmap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_free_pixmap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pixmap)
        )
    );
}
pub const xcb_gc_t_XCB_GC_FUNCTION: xcb_gc_t = 1;
pub const xcb_gc_t_XCB_GC_PLANE_MASK: xcb_gc_t = 2;
pub const xcb_gc_t_XCB_GC_FOREGROUND: xcb_gc_t = 4;
pub const xcb_gc_t_XCB_GC_BACKGROUND: xcb_gc_t = 8;
pub const xcb_gc_t_XCB_GC_LINE_WIDTH: xcb_gc_t = 16;
pub const xcb_gc_t_XCB_GC_LINE_STYLE: xcb_gc_t = 32;
pub const xcb_gc_t_XCB_GC_CAP_STYLE: xcb_gc_t = 64;
pub const xcb_gc_t_XCB_GC_JOIN_STYLE: xcb_gc_t = 128;
pub const xcb_gc_t_XCB_GC_FILL_STYLE: xcb_gc_t = 256;
pub const xcb_gc_t_XCB_GC_FILL_RULE: xcb_gc_t = 512;
pub const xcb_gc_t_XCB_GC_TILE: xcb_gc_t = 1024;
pub const xcb_gc_t_XCB_GC_STIPPLE: xcb_gc_t = 2048;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_X: xcb_gc_t = 4096;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_Y: xcb_gc_t = 8192;
pub const xcb_gc_t_XCB_GC_FONT: xcb_gc_t = 16384;
pub const xcb_gc_t_XCB_GC_SUBWINDOW_MODE: xcb_gc_t = 32768;
pub const xcb_gc_t_XCB_GC_GRAPHICS_EXPOSURES: xcb_gc_t = 65536;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_X: xcb_gc_t = 131072;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_Y: xcb_gc_t = 262144;
pub const xcb_gc_t_XCB_GC_CLIP_MASK: xcb_gc_t = 524288;
pub const xcb_gc_t_XCB_GC_DASH_OFFSET: xcb_gc_t = 1048576;
pub const xcb_gc_t_XCB_GC_DASH_LIST: xcb_gc_t = 2097152;
pub const xcb_gc_t_XCB_GC_ARC_MODE: xcb_gc_t = 4194304;
pub type xcb_gc_t = ::std::os::raw::c_uint;
pub const xcb_gx_t_XCB_GX_CLEAR: xcb_gx_t = 0;
pub const xcb_gx_t_XCB_GX_AND: xcb_gx_t = 1;
pub const xcb_gx_t_XCB_GX_AND_REVERSE: xcb_gx_t = 2;
pub const xcb_gx_t_XCB_GX_COPY: xcb_gx_t = 3;
pub const xcb_gx_t_XCB_GX_AND_INVERTED: xcb_gx_t = 4;
pub const xcb_gx_t_XCB_GX_NOOP: xcb_gx_t = 5;
pub const xcb_gx_t_XCB_GX_XOR: xcb_gx_t = 6;
pub const xcb_gx_t_XCB_GX_OR: xcb_gx_t = 7;
pub const xcb_gx_t_XCB_GX_NOR: xcb_gx_t = 8;
pub const xcb_gx_t_XCB_GX_EQUIV: xcb_gx_t = 9;
pub const xcb_gx_t_XCB_GX_INVERT: xcb_gx_t = 10;
pub const xcb_gx_t_XCB_GX_OR_REVERSE: xcb_gx_t = 11;
pub const xcb_gx_t_XCB_GX_COPY_INVERTED: xcb_gx_t = 12;
pub const xcb_gx_t_XCB_GX_OR_INVERTED: xcb_gx_t = 13;
pub const xcb_gx_t_XCB_GX_NAND: xcb_gx_t = 14;
pub const xcb_gx_t_XCB_GX_SET: xcb_gx_t = 15;
pub type xcb_gx_t = ::std::os::raw::c_uint;
pub const xcb_line_style_t_XCB_LINE_STYLE_SOLID: xcb_line_style_t = 0;
pub const xcb_line_style_t_XCB_LINE_STYLE_ON_OFF_DASH: xcb_line_style_t = 1;
pub const xcb_line_style_t_XCB_LINE_STYLE_DOUBLE_DASH: xcb_line_style_t = 2;
pub type xcb_line_style_t = ::std::os::raw::c_uint;
pub const xcb_cap_style_t_XCB_CAP_STYLE_NOT_LAST: xcb_cap_style_t = 0;
pub const xcb_cap_style_t_XCB_CAP_STYLE_BUTT: xcb_cap_style_t = 1;
pub const xcb_cap_style_t_XCB_CAP_STYLE_ROUND: xcb_cap_style_t = 2;
pub const xcb_cap_style_t_XCB_CAP_STYLE_PROJECTING: xcb_cap_style_t = 3;
pub type xcb_cap_style_t = ::std::os::raw::c_uint;
pub const xcb_join_style_t_XCB_JOIN_STYLE_MITER: xcb_join_style_t = 0;
pub const xcb_join_style_t_XCB_JOIN_STYLE_ROUND: xcb_join_style_t = 1;
pub const xcb_join_style_t_XCB_JOIN_STYLE_BEVEL: xcb_join_style_t = 2;
pub type xcb_join_style_t = ::std::os::raw::c_uint;
pub const xcb_fill_style_t_XCB_FILL_STYLE_SOLID: xcb_fill_style_t = 0;
pub const xcb_fill_style_t_XCB_FILL_STYLE_TILED: xcb_fill_style_t = 1;
pub const xcb_fill_style_t_XCB_FILL_STYLE_STIPPLED: xcb_fill_style_t = 2;
pub const xcb_fill_style_t_XCB_FILL_STYLE_OPAQUE_STIPPLED: xcb_fill_style_t = 3;
pub type xcb_fill_style_t = ::std::os::raw::c_uint;
pub const xcb_fill_rule_t_XCB_FILL_RULE_EVEN_ODD: xcb_fill_rule_t = 0;
pub const xcb_fill_rule_t_XCB_FILL_RULE_WINDING: xcb_fill_rule_t = 1;
pub type xcb_fill_rule_t = ::std::os::raw::c_uint;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN: xcb_subwindow_mode_t = 0;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS: xcb_subwindow_mode_t = 1;
pub type xcb_subwindow_mode_t = ::std::os::raw::c_uint;
pub const xcb_arc_mode_t_XCB_ARC_MODE_CHORD: xcb_arc_mode_t = 0;
pub const xcb_arc_mode_t_XCB_ARC_MODE_PIE_SLICE: xcb_arc_mode_t = 1;
pub type xcb_arc_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_create_gc_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_gc_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).foreground) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_style) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap_style) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_style) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_style) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_rule) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stipple) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_stipple_x_origin) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_stipple_y_origin) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subwindow_mode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphics_exposures) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_x_origin) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_y_origin) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_mask) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dashes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arc_mode) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[doc = " @brief xcb_create_gc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_gc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_change_gc_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_gc_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).foreground) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).background) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_style) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap_style) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_style) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_style) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_rule) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stipple) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_stipple_x_origin) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_stipple_y_origin) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subwindow_mode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphics_exposures) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_x_origin) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_y_origin) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_mask) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dashes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arc_mode) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[doc = " @brief xcb_change_gc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_gc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_copy_gc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_copy_gc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_gc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(src_gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(dst_gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_set_dashes_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_dashes_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_dashes_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_dashes_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dashes_len) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dashes_len)
        )
    );
}
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_UNSORTED: xcb_clip_ordering_t = 0;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_Y_SORTED: xcb_clip_ordering_t = 1;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_SORTED: xcb_clip_ordering_t = 2;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_BANDED: xcb_clip_ordering_t = 3;
pub type xcb_clip_ordering_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_clip_rectangles_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_clip_rectangles_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_clip_rectangles_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_clip_rectangles_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_clip_rectangles_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_clip_rectangles_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordering) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_x_origin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_y_origin) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
}
#[doc = " @brief xcb_free_gc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_free_gc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_free_gc_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_clear_area_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_clear_area_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_clear_area_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_clear_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposures) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(exposures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_copy_area_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_copy_area_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_area_request_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_drawable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_copy_plane_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_copy_plane_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_plane_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_plane_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_drawable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_plane) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(bit_plane)
        )
    );
}
pub const xcb_coord_mode_t_XCB_COORD_MODE_ORIGIN: xcb_coord_mode_t = 0;
pub const xcb_coord_mode_t_XCB_COORD_MODE_PREVIOUS: xcb_coord_mode_t = 1;
pub type xcb_coord_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_poly_point_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_point_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_point_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_point_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coordinate_mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_poly_line_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_line_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_line_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_line_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coordinate_mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_segment_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_segment_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y2)
        )
    );
}
#[doc = " @brief xcb_segment_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_segment_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_poly_segment_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_segment_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_segment_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_segment_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_poly_rectangle_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_rectangle_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_rectangle_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_poly_arc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_arc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_COMPLEX: xcb_poly_shape_t = 0;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_NONCONVEX: xcb_poly_shape_t = 1;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_CONVEX: xcb_poly_shape_t = 2;
pub type xcb_poly_shape_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_fill_poly_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_fill_poly_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_fill_poly_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fill_poly_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coordinate_mode) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_poly_fill_rectangle_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_fill_rectangle_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_poly_fill_rectangle_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief xcb_poly_fill_arc_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_fill_arc_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_BITMAP: xcb_image_format_t = 0;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_PIXMAP: xcb_image_format_t = 1;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_Z_PIXMAP: xcb_image_format_t = 2;
pub type xcb_image_format_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_put_image_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_put_image_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_put_image_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_put_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_y) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left_pad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(left_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_get_image_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_image_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_image_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_image_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
#[doc = " @brief xcb_get_image_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_image_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_poly_text_8_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_text_8_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_poly_text_16_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_poly_text_16_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_image_text_8_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_image_text_8_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @brief xcb_image_text_16_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_image_text_16_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_NONE: xcb_colormap_alloc_t = 0;
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_ALL: xcb_colormap_alloc_t = 1;
pub type xcb_colormap_alloc_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_create_colormap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_colormap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_colormap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(visual)
        )
    );
}
#[doc = " @brief xcb_free_colormap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_free_colormap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[doc = " @brief xcb_copy_colormap_and_free_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_copy_colormap_and_free_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_cmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(src_cmap)
        )
    );
}
#[doc = " @brief xcb_install_colormap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_install_colormap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_install_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_install_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[doc = " @brief xcb_uninstall_colormap_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_uninstall_colormap_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_uninstall_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_uninstall_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_uninstall_colormap_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_uninstall_colormap_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[doc = " @brief xcb_list_installed_colormaps_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_installed_colormaps_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_installed_colormaps_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_installed_colormaps_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief xcb_list_installed_colormaps_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_installed_colormaps_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmaps_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(cmaps_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_alloc_color_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_alloc_color_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_alloc_color_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
}
#[doc = " @brief xcb_alloc_named_color_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_named_color_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_alloc_named_color_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_named_color_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_alloc_named_color_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_named_color_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_red) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_green) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_red) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_green) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_blue) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
#[doc = " @brief xcb_alloc_color_cells_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_cells_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_alloc_color_cells_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_cells_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contiguous) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(planes)
        )
    );
}
#[doc = " @brief xcb_alloc_color_cells_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_cells_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixels_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).masks_len) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(masks_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_alloc_color_planes_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_planes_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_alloc_color_planes_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_planes_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_alloc_color_planes_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contiguous) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reds) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(reds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).greens) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(greens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blues) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(blues)
        )
    );
}
#[doc = " @brief xcb_alloc_color_planes_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_alloc_color_planes_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixels_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue_mask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad2)
        )
    );
}
#[doc = " @brief xcb_free_colors_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_free_colors_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colors_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
pub const xcb_color_flag_t_XCB_COLOR_FLAG_RED: xcb_color_flag_t = 1;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_GREEN: xcb_color_flag_t = 2;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_BLUE: xcb_color_flag_t = 4;
pub type xcb_color_flag_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_coloritem_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_coloritem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_coloritem_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_coloritem_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_store_colors_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_store_colors_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_store_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[doc = " @brief xcb_store_named_color_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_store_named_color_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_store_named_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_rgb_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_rgb_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_rgb_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_rgb_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_query_colors_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_colors_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_colors_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_colors_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[doc = " @brief xcb_query_colors_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_colors_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(colors_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_lookup_color_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_lookup_color_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_lookup_color_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_lookup_color_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_lookup_color_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_lookup_color_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_green) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_red) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_green) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_blue) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
pub const xcb_pixmap_enum_t_XCB_PIXMAP_NONE: xcb_pixmap_enum_t = 0;
pub type xcb_pixmap_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_create_cursor_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_cursor_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_red) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_green) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_blue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_red) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_green) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_blue) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_font_enum_t_XCB_FONT_NONE: xcb_font_enum_t = 0;
pub type xcb_font_enum_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_create_glyph_cursor_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_create_glyph_cursor_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_create_glyph_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_glyph_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_glyph_cursor_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_create_glyph_cursor_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_font) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_font)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_font) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_font)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_char) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_char) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_red) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_green) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_blue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_red) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_green) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_blue) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
#[doc = " @brief xcb_free_cursor_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_free_cursor_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_free_cursor_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " @brief xcb_recolor_cursor_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_recolor_cursor_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_recolor_cursor_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_recolor_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_green) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fore_blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_red) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_green) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).back_blue) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_LARGEST_CURSOR: xcb_query_shape_of_t = 0;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_TILE: xcb_query_shape_of_t = 1;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE: xcb_query_shape_of_t = 2;
pub type xcb_query_shape_of_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_query_best_size_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_best_size_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_best_size_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_best_size_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_query_best_size_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_best_size_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " @brief xcb_query_extension_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_extension_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_query_extension_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_extension_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[doc = " @brief xcb_query_extension_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_query_extension_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_event) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_error) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_error)
        )
    );
}
#[doc = " @brief xcb_list_extensions_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_extensions_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_extensions_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_extensions_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_list_extensions_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_extensions_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_change_keyboard_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_keyboard_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycode_count) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keycode_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_keycode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keysyms_per_keycode) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_mapping_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_mapping_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>(),
        6usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_keycode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_mapping_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_mapping_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keysyms_per_keycode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_kb_t_XCB_KB_KEY_CLICK_PERCENT: xcb_kb_t = 1;
pub const xcb_kb_t_XCB_KB_BELL_PERCENT: xcb_kb_t = 2;
pub const xcb_kb_t_XCB_KB_BELL_PITCH: xcb_kb_t = 4;
pub const xcb_kb_t_XCB_KB_BELL_DURATION: xcb_kb_t = 8;
pub const xcb_kb_t_XCB_KB_LED: xcb_kb_t = 16;
pub const xcb_kb_t_XCB_KB_LED_MODE: xcb_kb_t = 32;
pub const xcb_kb_t_XCB_KB_KEY: xcb_kb_t = 64;
pub const xcb_kb_t_XCB_KB_AUTO_REPEAT_MODE: xcb_kb_t = 128;
pub type xcb_kb_t = ::std::os::raw::c_uint;
pub const xcb_led_mode_t_XCB_LED_MODE_OFF: xcb_led_mode_t = 0;
pub const xcb_led_mode_t_XCB_LED_MODE_ON: xcb_led_mode_t = 1;
pub type xcb_led_mode_t = ::std::os::raw::c_uint;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_OFF: xcb_auto_repeat_mode_t = 0;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_ON: xcb_auto_repeat_mode_t = 1;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_DEFAULT: xcb_auto_repeat_mode_t = 2;
pub type xcb_auto_repeat_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_change_keyboard_control_value_list_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_keyboard_control_value_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_value_list_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_click_percent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_percent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_duration) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).led) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).led_mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auto_repeat_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[doc = " @brief xcb_change_keyboard_control_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_keyboard_control_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_control_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_control_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_control_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_control_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_keyboard_control_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_keyboard_control_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_reply_t>(),
        52usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_auto_repeat) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).led_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_click_percent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_percent) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_pitch) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bell_duration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auto_repeats) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[doc = " @brief xcb_bell_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_bell_request_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_bell_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bell_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percent) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_change_pointer_control_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_pointer_control_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_pointer_control_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acceleration_numerator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acceleration_denominator) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_acceleration) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_acceleration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_threshold) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_threshold)
        )
    );
}
#[doc = " @brief xcb_get_pointer_control_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_control_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_pointer_control_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_control_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_pointer_control_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_control_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acceleration_numerator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acceleration_denominator) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_blanking_t_XCB_BLANKING_NOT_PREFERRED: xcb_blanking_t = 0;
pub const xcb_blanking_t_XCB_BLANKING_PREFERRED: xcb_blanking_t = 1;
pub const xcb_blanking_t_XCB_BLANKING_DEFAULT: xcb_blanking_t = 2;
pub type xcb_blanking_t = ::std::os::raw::c_uint;
pub const xcb_exposures_t_XCB_EXPOSURES_NOT_ALLOWED: xcb_exposures_t = 0;
pub const xcb_exposures_t_XCB_EXPOSURES_ALLOWED: xcb_exposures_t = 1;
pub const xcb_exposures_t_XCB_EXPOSURES_DEFAULT: xcb_exposures_t = 2;
pub type xcb_exposures_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_screen_saver_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_screen_saver_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_screen_saver_request_t>(),
        10usize,
        concat!("Size of: ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefer_blanking) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_exposures) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(allow_exposures)
        )
    );
}
#[doc = " @brief xcb_get_screen_saver_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_screen_saver_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_screen_saver_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_screen_saver_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_screen_saver_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_screen_saver_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefer_blanking) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_exposures) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(allow_exposures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_host_mode_t_XCB_HOST_MODE_INSERT: xcb_host_mode_t = 0;
pub const xcb_host_mode_t_XCB_HOST_MODE_DELETE: xcb_host_mode_t = 1;
pub type xcb_host_mode_t = ::std::os::raw::c_uint;
pub const xcb_family_t_XCB_FAMILY_INTERNET: xcb_family_t = 0;
pub const xcb_family_t_XCB_FAMILY_DECNET: xcb_family_t = 1;
pub const xcb_family_t_XCB_FAMILY_CHAOS: xcb_family_t = 2;
pub const xcb_family_t_XCB_FAMILY_SERVER_INTERPRETED: xcb_family_t = 5;
pub const xcb_family_t_XCB_FAMILY_INTERNET_6: xcb_family_t = 6;
pub type xcb_family_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_change_hosts_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_change_hosts_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_change_hosts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_len) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[doc = " @brief xcb_host_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_host_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_host_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_host_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_host_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[doc = " @brief xcb_host_iterator_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_host_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_host_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " @brief xcb_list_hosts_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_hosts_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_list_hosts_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_hosts_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_list_hosts_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_list_hosts_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hosts_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(hosts_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_DISABLE: xcb_access_control_t = 0;
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_ENABLE: xcb_access_control_t = 1;
pub type xcb_access_control_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_access_control_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_access_control_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_access_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_access_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_access_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_access_control_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_close_down_t_XCB_CLOSE_DOWN_DESTROY_ALL: xcb_close_down_t = 0;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_PERMANENT: xcb_close_down_t = 1;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_TEMPORARY: xcb_close_down_t = 2;
pub type xcb_close_down_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_close_down_mode_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_close_down_mode_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_close_down_mode_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_close_down_mode_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_close_down_mode_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_close_down_mode_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_kill_t_XCB_KILL_ALL_TEMPORARY: xcb_kill_t = 0;
pub type xcb_kill_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_kill_client_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_kill_client_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_kill_client_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_kill_client_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(resource)
        )
    );
}
#[doc = " @brief xcb_rotate_properties_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_rotate_properties_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_rotate_properties_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rotate_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atoms_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(delta)
        )
    );
}
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_RESET: xcb_screen_saver_t = 0;
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_ACTIVE: xcb_screen_saver_t = 1;
pub type xcb_screen_saver_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_force_screen_saver_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_force_screen_saver_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_force_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_force_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_force_screen_saver_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_force_screen_saver_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_SUCCESS: xcb_mapping_status_t = 0;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_BUSY: xcb_mapping_status_t = 1;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_FAILURE: xcb_mapping_status_t = 2;
pub type xcb_mapping_status_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_pointer_mapping_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_pointer_mapping_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_set_pointer_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_pointer_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_set_pointer_mapping_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_pointer_mapping_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_pointer_mapping_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_mapping_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_pointer_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_pointer_mapping_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_pointer_mapping_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_map_index_t_XCB_MAP_INDEX_SHIFT: xcb_map_index_t = 0;
pub const xcb_map_index_t_XCB_MAP_INDEX_LOCK: xcb_map_index_t = 1;
pub const xcb_map_index_t_XCB_MAP_INDEX_CONTROL: xcb_map_index_t = 2;
pub const xcb_map_index_t_XCB_MAP_INDEX_1: xcb_map_index_t = 3;
pub const xcb_map_index_t_XCB_MAP_INDEX_2: xcb_map_index_t = 4;
pub const xcb_map_index_t_XCB_MAP_INDEX_3: xcb_map_index_t = 5;
pub const xcb_map_index_t_XCB_MAP_INDEX_4: xcb_map_index_t = 6;
pub const xcb_map_index_t_XCB_MAP_INDEX_5: xcb_map_index_t = 7;
pub type xcb_map_index_t = ::std::os::raw::c_uint;
#[doc = " @brief xcb_set_modifier_mapping_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_modifier_mapping_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_set_modifier_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_modifier_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycodes_per_modifier) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_set_modifier_mapping_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_set_modifier_mapping_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_modifier_mapping_cookie_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_modifier_mapping_cookie_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " @brief xcb_get_modifier_mapping_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_modifier_mapping_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " @brief xcb_get_modifier_mapping_reply_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_get_modifier_mapping_reply_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycodes_per_modifier) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[doc = " @brief xcb_no_operation_request_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_no_operation_request_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_no_operation_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_operation_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_char2b_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_char2b_t)"]
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_char2b_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_window_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_window_t)"]
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_window_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_pixmap_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_pixmap_t)"]
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_pixmap_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_cursor_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_cursor_t)"]
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_cursor_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_font_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_font_t)"]
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_font_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_gcontext_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_gcontext_t)"]
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_gcontext_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_colormap_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_colormap_t)"]
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_colormap_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_atom_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_atom_t)"]
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_atom_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_drawable_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_drawable_t)"]
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_drawable_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_fontable_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_fontable_t)"]
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_fontable_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_bool32_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_bool32_t)"]
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_bool32_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_visualid_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_visualid_t)"]
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_visualid_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_timestamp_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_timestamp_t)"]
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_timestamp_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_keysym_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_keysym_t)"]
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_keysym_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_keycode_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_keycode_t)"]
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_keycode_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_keycode32_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_keycode32_t)"]
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_keycode32_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_button_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_button_t)"]
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_button_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_point_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_point_t)"]
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_point_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_rectangle_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_rectangle_t)"]
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_rectangle_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_arc_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_arc_t)"]
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_arc_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_format_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_format_t)"]
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_format_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_visualtype_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_visualtype_t)"]
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_visualtype_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t) -> xcb_visualtype_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_depth_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_depth_t)"]
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_depth_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t) -> xcb_depth_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_screen_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_screen_t)"]
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_screen_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_setup_request_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_setup_request_t)"]
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_setup_request_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_setup_failed_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_setup_failed_t)"]
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_setup_failed_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(
        R: *const xcb_setup_authenticate_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(
        R: *const xcb_setup_authenticate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(
        R: *const xcb_setup_authenticate_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_setup_authenticate_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_setup_authenticate_t)"]
    pub fn xcb_setup_authenticate_next(i: *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_setup_authenticate_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_setup_authenticate_end(
        i: xcb_setup_authenticate_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t) -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t) -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t) -> xcb_screen_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_setup_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_setup_t)"]
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_setup_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_client_message_data_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_client_message_data_t)"]
    pub fn xcb_client_message_data_next(i: *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_client_message_data_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_client_message_data_end(
        i: xcb_client_message_data_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates a window\n\n @param c The connection\n @param depth Specifies the new window's depth (TODO: what unit?).\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the\n \\a parent window.\n @param wid The ID with which you will refer to the new window, created by\n `xcb_generate_id`.\n @param parent The parent window of the new window.\n @param x The X coordinate of the new window.\n @param y The Y coordinate of the new window.\n @param width The width of the new window.\n @param height The height of the new window.\n @param border_width TODO:\n \\n\n Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.\n @param _class A bitmask of #xcb_window_class_t values.\n @param _class \\n\n @param visual Specifies the id for the new window's visual.\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the\n \\a parent window.\n @param value_mask A bitmask of #xcb_cw_t values.\n @return A cookie\n\n Creates an unmapped window as child of the specified \\a parent window. A\n CreateNotify event will be generated. The new window is placed on top in the\n stacking order with respect to siblings.\n\n The coordinate system has the X axis horizontal and the Y axis vertical with\n the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms\n of pixels, and coincide with pixel centers. Each window and pixmap has its own\n coordinate system. For a window, the origin is inside the border at the inside,\n upper-left corner.\n\n The created window is not yet displayed (mapped), call `xcb_map_window` to\n display it.\n\n The created window will initially use the same cursor as its parent.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_window_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a window\n\n @param c The connection\n @param depth Specifies the new window's depth (TODO: what unit?).\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the\n \\a parent window.\n @param wid The ID with which you will refer to the new window, created by\n `xcb_generate_id`.\n @param parent The parent window of the new window.\n @param x The X coordinate of the new window.\n @param y The Y coordinate of the new window.\n @param width The width of the new window.\n @param height The height of the new window.\n @param border_width TODO:\n \\n\n Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.\n @param _class A bitmask of #xcb_window_class_t values.\n @param _class \\n\n @param visual Specifies the id for the new window's visual.\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the\n \\a parent window.\n @param value_mask A bitmask of #xcb_cw_t values.\n @return A cookie\n\n Creates an unmapped window as child of the specified \\a parent window. A\n CreateNotify event will be generated. The new window is placed on top in the\n stacking order with respect to siblings.\n\n The coordinate system has the X axis horizontal and the Y axis vertical with\n the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms\n of pixels, and coincide with pixel centers. Each window and pixmap has its own\n coordinate system. For a window, the origin is inside the border at the inside,\n upper-left corner.\n\n The created window is not yet displayed (mapped), call `xcb_map_window` to\n display it.\n\n The created window will initially use the same cursor as its parent.\n"]
    pub fn xcb_create_window(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a window\n\n @param c The connection\n @param depth Specifies the new window's depth (TODO: what unit?).\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the\n \\a parent window.\n @param wid The ID with which you will refer to the new window, created by\n `xcb_generate_id`.\n @param parent The parent window of the new window.\n @param x The X coordinate of the new window.\n @param y The Y coordinate of the new window.\n @param width The width of the new window.\n @param height The height of the new window.\n @param border_width TODO:\n \\n\n Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.\n @param _class A bitmask of #xcb_window_class_t values.\n @param _class \\n\n @param visual Specifies the id for the new window's visual.\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the\n \\a parent window.\n @param value_mask A bitmask of #xcb_cw_t values.\n @return A cookie\n\n Creates an unmapped window as child of the specified \\a parent window. A\n CreateNotify event will be generated. The new window is placed on top in the\n stacking order with respect to siblings.\n\n The coordinate system has the X axis horizontal and the Y axis vertical with\n the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms\n of pixels, and coincide with pixel centers. Each window and pixmap has its own\n coordinate system. For a window, the origin is inside the border at the inside,\n upper-left corner.\n\n The created window is not yet displayed (mapped), call `xcb_map_window` to\n display it.\n\n The created window will initially use the same cursor as its parent.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_window_aux_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a window\n\n @param c The connection\n @param depth Specifies the new window's depth (TODO: what unit?).\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the\n \\a parent window.\n @param wid The ID with which you will refer to the new window, created by\n `xcb_generate_id`.\n @param parent The parent window of the new window.\n @param x The X coordinate of the new window.\n @param y The Y coordinate of the new window.\n @param width The width of the new window.\n @param height The height of the new window.\n @param border_width TODO:\n \\n\n Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.\n @param _class A bitmask of #xcb_window_class_t values.\n @param _class \\n\n @param visual Specifies the id for the new window's visual.\n \\n\n The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the\n \\a parent window.\n @param value_mask A bitmask of #xcb_cw_t values.\n @return A cookie\n\n Creates an unmapped window as child of the specified \\a parent window. A\n CreateNotify event will be generated. The new window is placed on top in the\n stacking order with respect to siblings.\n\n The coordinate system has the X axis horizontal and the Y axis vertical with\n the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms\n of pixels, and coincide with pixel centers. Each window and pixmap has its own\n coordinate system. For a window, the origin is inside the border at the inside,\n upper-left corner.\n\n The created window is not yet displayed (mapped), call `xcb_map_window` to\n display it.\n\n The created window will initially use the same cursor as its parent.\n"]
    pub fn xcb_create_window_aux(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(
        R: *const xcb_create_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief change window attributes\n\n @param c The connection\n @param window The window to change.\n @param value_mask A bitmask of #xcb_cw_t values.\n @param value_mask \\n\n @param value_list Values for each of the attributes specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the attributes specified by \\a value_mask for the specified \\a window.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_window_attributes_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change window attributes\n\n @param c The connection\n @param window The window to change.\n @param value_mask A bitmask of #xcb_cw_t values.\n @param value_mask \\n\n @param value_list Values for each of the attributes specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the attributes specified by \\a value_mask for the specified \\a window.\n"]
    pub fn xcb_change_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change window attributes\n\n @param c The connection\n @param window The window to change.\n @param value_mask A bitmask of #xcb_cw_t values.\n @param value_mask \\n\n @param value_list Values for each of the attributes specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the attributes specified by \\a value_mask for the specified \\a window.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_window_attributes_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change window attributes\n\n @param c The connection\n @param window The window to change.\n @param value_mask A bitmask of #xcb_cw_t values.\n @param value_mask \\n\n @param value_list Values for each of the attributes specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the attributes specified by \\a value_mask for the specified \\a window.\n"]
    pub fn xcb_change_window_attributes_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(
        R: *const xcb_change_window_attributes_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Gets window attributes\n\n @param c The connection\n @param window The window to get the attributes from.\n @return A cookie\n\n Gets the current attributes for the specified \\a window.\n"]
    pub fn xcb_get_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    #[doc = " @brief Gets window attributes\n\n @param c The connection\n @param window The window to get the attributes from.\n @return A cookie\n\n Gets the current attributes for the specified \\a window.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_window_attributes_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_window_attributes_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_window_attributes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_window_attributes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    #[doc = " @brief Destroys a window\n\n @param c The connection\n @param window The window to destroy.\n @return A cookie\n\n Destroys the specified window and all of its subwindows. A DestroyNotify event\n is generated for each destroyed window (a DestroyNotify event is first generated\n for any given window's inferiors). If the window was mapped, it will be\n automatically unmapped before destroying.\n\n Calling DestroyWindow on the root window will do nothing.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_destroy_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Destroys a window\n\n @param c The connection\n @param window The window to destroy.\n @return A cookie\n\n Destroys the specified window and all of its subwindows. A DestroyNotify event\n is generated for each destroyed window (a DestroyNotify event is first generated\n for any given window's inferiors). If the window was mapped, it will be\n automatically unmapped before destroying.\n\n Calling DestroyWindow on the root window will do nothing.\n"]
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_destroy_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_destroy_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Changes a client's save set\n\n @param c The connection\n @param mode A bitmask of #xcb_set_mode_t values.\n @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.\n @param window The window to add or delete to/from your save set.\n @return A cookie\n\n TODO: explain what the save set is for.\n\n This function either adds or removes the specified window to the client's (your\n application's) save set.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_save_set_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Changes a client's save set\n\n @param c The connection\n @param mode A bitmask of #xcb_set_mode_t values.\n @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.\n @param window The window to add or delete to/from your save set.\n @return A cookie\n\n TODO: explain what the save set is for.\n\n This function either adds or removes the specified window to the client's (your\n application's) save set.\n"]
    pub fn xcb_change_save_set(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Reparents a window\n\n @param c The connection\n @param window The window to reparent.\n @param parent The new parent of the window.\n @param x The X position of the window within its new parent.\n @param y The Y position of the window within its new parent.\n @return A cookie\n\n Makes the specified window a child of the specified parent window. If the\n window is mapped, it will automatically be unmapped before reparenting and\n re-mapped after reparenting. The window is placed in the stacking order on top\n with respect to sibling windows.\n\n After reparenting, a ReparentNotify event is generated.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_reparent_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Reparents a window\n\n @param c The connection\n @param window The window to reparent.\n @param parent The new parent of the window.\n @param x The X position of the window within its new parent.\n @param y The Y position of the window within its new parent.\n @return A cookie\n\n Makes the specified window a child of the specified parent window. If the\n window is mapped, it will automatically be unmapped before reparenting and\n re-mapped after reparenting. The window is placed in the stacking order on top\n with respect to sibling windows.\n\n After reparenting, a ReparentNotify event is generated.\n"]
    pub fn xcb_reparent_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Makes a window visible\n\n @param c The connection\n @param window The window to make visible.\n @return A cookie\n\n Maps the specified window. This means making the window visible (as long as its\n parent is visible).\n\n This MapWindow request will be translated to a MapRequest request if a window\n manager is running. The window manager then decides to either map the window or\n not. Set the override-redirect window attribute to true if you want to bypass\n this mechanism.\n\n If the window manager decides to map the window (or if no window manager is\n running), a MapNotify event is generated.\n\n If the window becomes viewable and no earlier contents for it are remembered,\n the X server tiles the window with its background. If the window's background\n is undefined, the existing screen contents are not altered, and the X server\n generates zero or more Expose events.\n\n If the window type is InputOutput, an Expose event will be generated when the\n window becomes visible. The normal response to an Expose event should be to\n repaint the window.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_map_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Makes a window visible\n\n @param c The connection\n @param window The window to make visible.\n @return A cookie\n\n Maps the specified window. This means making the window visible (as long as its\n parent is visible).\n\n This MapWindow request will be translated to a MapRequest request if a window\n manager is running. The window manager then decides to either map the window or\n not. Set the override-redirect window attribute to true if you want to bypass\n this mechanism.\n\n If the window manager decides to map the window (or if no window manager is\n running), a MapNotify event is generated.\n\n If the window becomes viewable and no earlier contents for it are remembered,\n the X server tiles the window with its background. If the window's background\n is undefined, the existing screen contents are not altered, and the X server\n generates zero or more Expose events.\n\n If the window type is InputOutput, an Expose event will be generated when the\n window becomes visible. The normal response to an Expose event should be to\n repaint the window.\n"]
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_map_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Makes a window invisible\n\n @param c The connection\n @param window The window to make invisible.\n @return A cookie\n\n Unmaps the specified window. This means making the window invisible (and all\n its child windows).\n\n Unmapping a window leads to the `UnmapNotify` event being generated. Also,\n `Expose` events are generated for formerly obscured windows.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_unmap_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Makes a window invisible\n\n @param c The connection\n @param window The window to make invisible.\n @return A cookie\n\n Unmaps the specified window. This means making the window invisible (and all\n its child windows).\n\n Unmapping a window leads to the `UnmapNotify` event being generated. Also,\n `Expose` events are generated for formerly obscured windows.\n"]
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_unmap_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_unmap_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *const xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *mut xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Configures window attributes\n\n @param c The connection\n @param window The window to configure.\n @param value_mask Bitmask of attributes to change.\n @param value_list New values, corresponding to the attributes in value_mask. The order has to\n correspond to the order of possible \\a value_mask bits. See the example.\n @return A cookie\n\n Configures a window's size, position, border width and stacking order.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_configure_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Configures window attributes\n\n @param c The connection\n @param window The window to configure.\n @param value_mask Bitmask of attributes to change.\n @param value_list New values, corresponding to the attributes in value_mask. The order has to\n correspond to the order of possible \\a value_mask bits. See the example.\n @return A cookie\n\n Configures a window's size, position, border width and stacking order.\n"]
    pub fn xcb_configure_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Configures window attributes\n\n @param c The connection\n @param window The window to configure.\n @param value_mask Bitmask of attributes to change.\n @param value_list New values, corresponding to the attributes in value_mask. The order has to\n correspond to the order of possible \\a value_mask bits. See the example.\n @return A cookie\n\n Configures a window's size, position, border width and stacking order.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_configure_window_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Configures window attributes\n\n @param c The connection\n @param window The window to configure.\n @param value_mask Bitmask of attributes to change.\n @param value_list New values, corresponding to the attributes in value_mask. The order has to\n correspond to the order of possible \\a value_mask bits. See the example.\n @return A cookie\n\n Configures a window's size, position, border width and stacking order.\n"]
    pub fn xcb_configure_window_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(
        R: *const xcb_configure_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Change window stacking order\n\n @param c The connection\n @param direction A bitmask of #xcb_circulate_t values.\n @param direction \\n\n @param window The window to raise/lower (depending on \\a direction).\n @return A cookie\n\n If \\a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if\n any) will be raised to the top of the stack.\n\n If \\a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will\n be lowered to the bottom of the stack.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_circulate_window_checked(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Change window stacking order\n\n @param c The connection\n @param direction A bitmask of #xcb_circulate_t values.\n @param direction \\n\n @param window The window to raise/lower (depending on \\a direction).\n @return A cookie\n\n If \\a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if\n any) will be raised to the top of the stack.\n\n If \\a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will\n be lowered to the bottom of the stack.\n"]
    pub fn xcb_circulate_window(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Get current window geometry\n\n @param c The connection\n @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.\n @return A cookie\n\n Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).\n"]
    pub fn xcb_get_geometry(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    #[doc = " @brief Get current window geometry\n\n @param c The connection\n @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.\n @return A cookie\n\n Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_geometry_unchecked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_geometry_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_geometry_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_geometry_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief query the window tree\n\n @param c The connection\n @param window The \\a window to query.\n @return A cookie\n\n Gets the root window ID, parent window ID and list of children windows for the\n specified \\a window. The children are listed in bottom-to-top stacking order.\n"]
    pub fn xcb_query_tree(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    #[doc = " @brief query the window tree\n\n @param c The connection\n @param window The \\a window to query.\n @return A cookie\n\n Gets the root window ID, parent window ID and list of children windows for the\n specified \\a window. The children are listed in bottom-to-top stacking order.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_tree_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t) -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(
        R: *const xcb_query_tree_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_tree_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_tree_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_tree_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get atom identifier by name\n\n @param c The connection\n @param only_if_exists Return a valid atom id only if the atom already exists.\n @param name_len The length of the following \\a name.\n @param name The name of the atom.\n @return A cookie\n\n Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified\n name. Atoms are used in protocols like EWMH, for example to store window titles\n (`_NET_WM_NAME` atom) as property of a window.\n\n If \\a only_if_exists is 0, the atom will be created if it does not already exist.\n If \\a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does\n not yet exist.\n"]
    pub fn xcb_intern_atom(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    #[doc = " @brief Get atom identifier by name\n\n @param c The connection\n @param only_if_exists Return a valid atom id only if the atom already exists.\n @param name_len The length of the following \\a name.\n @param name The name of the atom.\n @return A cookie\n\n Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified\n name. Atoms are used in protocols like EWMH, for example to store window titles\n (`_NET_WM_NAME` atom) as property of a window.\n\n If \\a only_if_exists is 0, the atom will be created if it does not already exist.\n If \\a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does\n not yet exist.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_intern_atom_unchecked(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_intern_atom_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_intern_atom_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_intern_atom_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_atom_name(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_atom_name_unchecked(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(
        R: *const xcb_get_atom_name_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(
        R: *const xcb_get_atom_name_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(
        R: *const xcb_get_atom_name_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_atom_name_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_atom_name_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_atom_name_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Changes a window property\n\n @param c The connection\n @param mode A bitmask of #xcb_prop_mode_t values.\n @param mode \\n\n @param window The window whose property you want to change.\n @param property The property you want to change (an atom).\n @param type The type of the property you want to change (an atom).\n @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or\n 32-bit quantities. Possible values are 8, 16 and 32. This information allows\n the X server to correctly perform byte-swap operations as necessary.\n @param data_len Specifies the number of elements (see \\a format).\n @param data The property data.\n @return A cookie\n\n Sets or updates a property on the specified \\a window. Properties are for\n example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).\n Protocols such as EWMH also use properties - for example EWMH defines the\n window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_property_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Changes a window property\n\n @param c The connection\n @param mode A bitmask of #xcb_prop_mode_t values.\n @param mode \\n\n @param window The window whose property you want to change.\n @param property The property you want to change (an atom).\n @param type The type of the property you want to change (an atom).\n @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or\n 32-bit quantities. Possible values are 8, 16 and 32. This information allows\n the X server to correctly perform byte-swap operations as necessary.\n @param data_len Specifies the number of elements (see \\a format).\n @param data The property data.\n @return A cookie\n\n Sets or updates a property on the specified \\a window. Properties are for\n example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).\n Protocols such as EWMH also use properties - for example EWMH defines the\n window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.\n"]
    pub fn xcb_change_property(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(
        R: *const xcb_change_property_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(
        R: *const xcb_change_property_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(
        R: *const xcb_change_property_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_delete_property_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_delete_property(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets a window property\n\n @param c The connection\n @param _delete Whether the property should actually be deleted. For deleting a property, the\n specified \\a type has to match the actual property type.\n @param window The window whose property you want to get.\n @param property The property you want to get (an atom).\n @param type The type of the property you want to get (an atom).\n @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the\n data is to be retrieved.\n @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you\n set \\a long_length to 4, you will receive 16 bytes of data).\n @return A cookie\n\n Gets the specified \\a property from the specified \\a window. Properties are for\n example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).\n Protocols such as EWMH also use properties - for example EWMH defines the\n window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.\n\n TODO: talk about \\a type\n\n TODO: talk about `delete`\n\n TODO: talk about the offset/length thing. what's a valid use case?\n"]
    pub fn xcb_get_property(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    #[doc = " @brief Gets a window property\n\n @param c The connection\n @param _delete Whether the property should actually be deleted. For deleting a property, the\n specified \\a type has to match the actual property type.\n @param window The window whose property you want to get.\n @param property The property you want to get (an atom).\n @param type The type of the property you want to get (an atom).\n @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the\n data is to be retrieved.\n @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you\n set \\a long_length to 4, you will receive 16 bytes of data).\n @return A cookie\n\n Gets the specified \\a property from the specified \\a window. Properties are for\n example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).\n Protocols such as EWMH also use properties - for example EWMH defines the\n window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.\n\n TODO: talk about \\a type\n\n TODO: talk about `delete`\n\n TODO: talk about the offset/length thing. what's a valid use case?\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_property_unchecked(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(
        R: *const xcb_get_property_reply_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(
        R: *const xcb_get_property_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_property_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_property_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_property_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_list_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_properties_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(
        R: *const xcb_list_properties_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(
        R: *const xcb_list_properties_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_properties_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_properties_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_properties_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    #[doc = " @brief Sets the owner of a selection\n\n @param c The connection\n @param owner The new owner of the selection.\n \\n\n The special value `XCB_NONE` means that the selection will have no owner.\n @param selection The selection.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The selection will not be changed if \\a time is earlier than the current\n last-change time of the \\a selection or is later than the current X server time.\n Otherwise, the last-change time is set to the specified time.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Makes `window` the owner of the selection \\a selection and updates the\n last-change time of the specified selection.\n\n TODO: briefly explain what a selection is.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_selection_owner_checked(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Sets the owner of a selection\n\n @param c The connection\n @param owner The new owner of the selection.\n \\n\n The special value `XCB_NONE` means that the selection will have no owner.\n @param selection The selection.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The selection will not be changed if \\a time is earlier than the current\n last-change time of the \\a selection or is later than the current X server time.\n Otherwise, the last-change time is set to the specified time.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Makes `window` the owner of the selection \\a selection and updates the\n last-change time of the specified selection.\n\n TODO: briefly explain what a selection is.\n"]
    pub fn xcb_set_selection_owner(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Gets the owner of a selection\n\n @param c The connection\n @param selection The selection.\n @return A cookie\n\n Gets the owner of the specified selection.\n\n TODO: briefly explain what a selection is.\n"]
    pub fn xcb_get_selection_owner(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    #[doc = " @brief Gets the owner of a selection\n\n @param c The connection\n @param selection The selection.\n @return A cookie\n\n Gets the owner of the specified selection.\n\n TODO: briefly explain what a selection is.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_selection_owner_unchecked(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_selection_owner_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_selection_owner_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_selection_owner_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_convert_selection_checked(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_convert_selection(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief send an event\n\n @param c The connection\n @param propagate If \\a propagate is true and no clients have selected any event on \\a destination,\n the destination is replaced with the closest ancestor of \\a destination for\n which some client has selected a type in \\a event_mask and for which no\n intervening window has that type in its do-not-propagate-mask. If no such\n window exists or if the window is an ancestor of the focus window and\n `InputFocus` was originally specified as the destination, the event is not sent\n to any clients. Otherwise, the event is reported to every client selecting on\n the final destination any of the types specified in \\a event_mask.\n @param destination The window to send this event to. Every client which selects any event within\n \\a event_mask on \\a destination will get the event.\n \\n\n The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window\n that contains the mouse pointer.\n \\n\n The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which\n has the keyboard focus.\n @param event_mask Event_mask for determining which clients should receive the specified event.\n See \\a destination and \\a propagate.\n @param event The event to send to the specified \\a destination.\n @return A cookie\n\n Identifies the \\a destination window, determines which clients should receive\n the specified event and ignores any active grabs.\n\n The \\a event must be one of the core events or an event defined by an extension,\n so that the X server can correctly byte-swap the contents as necessary. The\n contents of \\a event are otherwise unaltered and unchecked except for the\n `send_event` field which is forced to 'true'.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_send_event_checked(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief send an event\n\n @param c The connection\n @param propagate If \\a propagate is true and no clients have selected any event on \\a destination,\n the destination is replaced with the closest ancestor of \\a destination for\n which some client has selected a type in \\a event_mask and for which no\n intervening window has that type in its do-not-propagate-mask. If no such\n window exists or if the window is an ancestor of the focus window and\n `InputFocus` was originally specified as the destination, the event is not sent\n to any clients. Otherwise, the event is reported to every client selecting on\n the final destination any of the types specified in \\a event_mask.\n @param destination The window to send this event to. Every client which selects any event within\n \\a event_mask on \\a destination will get the event.\n \\n\n The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window\n that contains the mouse pointer.\n \\n\n The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which\n has the keyboard focus.\n @param event_mask Event_mask for determining which clients should receive the specified event.\n See \\a destination and \\a propagate.\n @param event The event to send to the specified \\a destination.\n @return A cookie\n\n Identifies the \\a destination window, determines which clients should receive\n the specified event and ignores any active grabs.\n\n The \\a event must be one of the core events or an event defined by an extension,\n so that the X server can correctly byte-swap the contents as necessary. The\n contents of \\a event are otherwise unaltered and unchecked except for the\n `send_event` field which is forced to 'true'.\n"]
    pub fn xcb_send_event(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab the pointer\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param event_mask Specifies which pointer events are reported to the client.\n \\n\n TODO: which values?\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @param confine_to Specifies the window to confine the pointer in (the user will not be able to\n move the pointer out of that window).\n \\n\n The special value `XCB_NONE` means don't confine the pointer.\n @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the\n cursor.\n @param time The time argument allows you to avoid certain circumstances that come up if\n applications take a long time to respond or if there are long network delays.\n Consider a situation where you have two applications, both of which normally\n grab the pointer when clicked on. If both applications specify the timestamp\n from the event, the second application may wake up faster and successfully grab\n the pointer before the first application. The first application then will get\n an indication that the other application grabbed the pointer before its request\n was processed.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.\n"]
    pub fn xcb_grab_pointer(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab the pointer\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param event_mask Specifies which pointer events are reported to the client.\n \\n\n TODO: which values?\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @param confine_to Specifies the window to confine the pointer in (the user will not be able to\n move the pointer out of that window).\n \\n\n The special value `XCB_NONE` means don't confine the pointer.\n @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the\n cursor.\n @param time The time argument allows you to avoid certain circumstances that come up if\n applications take a long time to respond or if there are long network delays.\n Consider a situation where you have two applications, both of which normally\n grab the pointer when clicked on. If both applications specify the timestamp\n from the event, the second application may wake up faster and successfully grab\n the pointer before the first application. The first application then will get\n an indication that the other application grabbed the pointer before its request\n was processed.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_grab_pointer_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_grab_pointer_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_grab_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    #[doc = " @brief release the pointer\n\n @param c The connection\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The pointer will not be released if \\a time is earlier than the\n last-pointer-grab time or later than the current X server time.\n @return A cookie\n\n Releases the pointer and any queued events if you actively grabbed the pointer\n before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button\n press.\n\n EnterNotify and LeaveNotify events are generated.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_ungrab_pointer_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief release the pointer\n\n @param c The connection\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The pointer will not be released if \\a time is earlier than the\n last-pointer-grab time or later than the current X server time.\n @return A cookie\n\n Releases the pointer and any queued events if you actively grabbed the pointer\n before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button\n press.\n\n EnterNotify and LeaveNotify events are generated.\n"]
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
        -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab pointer button(s)\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param event_mask Specifies which pointer events are reported to the client.\n \\n\n TODO: which values?\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @param confine_to Specifies the window to confine the pointer in (the user will not be able to\n move the pointer out of that window).\n \\n\n The special value `XCB_NONE` means don't confine the pointer.\n @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the\n cursor.\n @param button A bitmask of #xcb_button_index_t values.\n @param button \\n\n @param modifiers The modifiers to grab.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all\n possible modifier combinations.\n @return A cookie\n\n This request establishes a passive grab. The pointer is actively grabbed as\n described in GrabPointer, the last-pointer-grab time is set to the time at\n which the button was pressed (as transmitted in the ButtonPress event), and the\n ButtonPress event is reported if all of the following conditions are true:\n\n The pointer is not grabbed and the specified button is logically pressed when\n the specified modifier keys are logically down, and no other buttons or\n modifier keys are logically down.\n\n The grab-window contains the pointer.\n\n The confine-to window (if any) is viewable.\n\n A passive grab on the same button/key combination does not exist on any\n ancestor of grab-window.\n\n The interpretation of the remaining arguments is the same as for GrabPointer.\n The active grab is terminated automatically when the logical state of the\n pointer has all buttons released, independent of the logical state of modifier\n keys. Note that the logical state of a device (as seen by means of the\n protocol) may lag the physical state if device event processing is frozen. This\n request overrides all previous passive grabs by the same client on the same\n button/key combinations on the same window. A modifier of AnyModifier is\n equivalent to issuing the request for all possible modifier combinations\n (including the combination of no modifiers). It is not required that all\n specified modifiers have currently assigned keycodes. A button of AnyButton is\n equivalent to issuing the request for all possible buttons. Otherwise, it is\n not required that the button specified currently be assigned to a physical\n button.\n\n An Access error is generated if some other client has already issued a\n GrabButton request with the same button/key combination on the same window.\n When using AnyModifier or AnyButton, the request fails completely (no grabs are\n established), and an Access error is generated if there is a conflicting grab\n for any combination. The request has no effect on an active grab.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_grab_button_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab pointer button(s)\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param event_mask Specifies which pointer events are reported to the client.\n \\n\n TODO: which values?\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @param confine_to Specifies the window to confine the pointer in (the user will not be able to\n move the pointer out of that window).\n \\n\n The special value `XCB_NONE` means don't confine the pointer.\n @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the\n cursor.\n @param button A bitmask of #xcb_button_index_t values.\n @param button \\n\n @param modifiers The modifiers to grab.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all\n possible modifier combinations.\n @return A cookie\n\n This request establishes a passive grab. The pointer is actively grabbed as\n described in GrabPointer, the last-pointer-grab time is set to the time at\n which the button was pressed (as transmitted in the ButtonPress event), and the\n ButtonPress event is reported if all of the following conditions are true:\n\n The pointer is not grabbed and the specified button is logically pressed when\n the specified modifier keys are logically down, and no other buttons or\n modifier keys are logically down.\n\n The grab-window contains the pointer.\n\n The confine-to window (if any) is viewable.\n\n A passive grab on the same button/key combination does not exist on any\n ancestor of grab-window.\n\n The interpretation of the remaining arguments is the same as for GrabPointer.\n The active grab is terminated automatically when the logical state of the\n pointer has all buttons released, independent of the logical state of modifier\n keys. Note that the logical state of a device (as seen by means of the\n protocol) may lag the physical state if device event processing is frozen. This\n request overrides all previous passive grabs by the same client on the same\n button/key combinations on the same window. A modifier of AnyModifier is\n equivalent to issuing the request for all possible modifier combinations\n (including the combination of no modifiers). It is not required that all\n specified modifiers have currently assigned keycodes. A button of AnyButton is\n equivalent to issuing the request for all possible buttons. Otherwise, it is\n not required that the button specified currently be assigned to a physical\n button.\n\n An Access error is generated if some other client has already issued a\n GrabButton request with the same button/key combination on the same window.\n When using AnyModifier or AnyButton, the request fails completely (no grabs are\n established), and an Access error is generated if there is a conflicting grab\n for any combination. The request has no effect on an active grab.\n"]
    pub fn xcb_grab_button(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_ungrab_button_checked(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_ungrab_button(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_active_pointer_grab_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_active_pointer_grab(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab the keyboard\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @return A cookie\n\n Actively grabs control of the keyboard and generates FocusIn and FocusOut\n events. Further key events are reported only to the grabbing client.\n\n Any active keyboard grab by this client is overridden. If the keyboard is\n actively grabbed by some other client, `AlreadyGrabbed` is returned. If\n \\a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard\n is frozen by an active grab of another client, `GrabFrozen` is returned. If the\n specified \\a time is earlier than the last-keyboard-grab time or later than the\n current X server time, `GrabInvalidTime` is returned. Otherwise, the\n last-keyboard-grab time is set to the specified time.\n"]
    pub fn xcb_grab_keyboard(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab the keyboard\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the pointer events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the pointer should be grabbed.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @return A cookie\n\n Actively grabs control of the keyboard and generates FocusIn and FocusOut\n events. Further key events are reported only to the grabbing client.\n\n Any active keyboard grab by this client is overridden. If the keyboard is\n actively grabbed by some other client, `AlreadyGrabbed` is returned. If\n \\a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard\n is frozen by an active grab of another client, `GrabFrozen` is returned. If the\n specified \\a time is earlier than the last-keyboard-grab time or later than the\n current X server time, `GrabInvalidTime` is returned. Otherwise, the\n last-keyboard-grab time is set to the specified time.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_grab_keyboard_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_grab_keyboard_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_grab_keyboard_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_keyboard_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_ungrab_keyboard_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_ungrab_keyboard(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab keyboard key(s)\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the key events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the key should be grabbed.\n @param modifiers The modifiers to grab.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means grab the key with all\n possible modifier combinations.\n @param key The keycode of the key to grab.\n \\n\n The special value `XCB_GRAB_ANY` means grab any key.\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @return A cookie\n\n Establishes a passive grab on the keyboard. In the future, the keyboard is\n actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to\n the time at which the key was pressed (as transmitted in the KeyPress event),\n and the KeyPress event is reported if all of the following conditions are true:\n\n The keyboard is not grabbed and the specified key (which can itself be a\n modifier key) is logically pressed when the specified modifier keys are\n logically down, and no other modifier keys are logically down.\n\n Either the grab_window is an ancestor of (or is) the focus window, or the\n grab_window is a descendant of the focus window and contains the pointer.\n\n A passive grab on the same key combination does not exist on any ancestor of\n grab_window.\n\n The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated\n automatically when the logical state of the keyboard has the specified key released (independent of the\n logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.\n\n Note that the logical state of a device (as seen by client applications) may lag the physical state if\n device event processing is frozen.\n\n A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified\n have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for\n all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode\n and max_keycode in the connection setup, or a BadValue error results.\n\n If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess\n error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error\n results (no grabs are established) if there is a conflicting grab for any combination.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_grab_key_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Grab keyboard key(s)\n\n @param c The connection\n @param owner_events If 1, the \\a grab_window will still get the key events. If 0, events are not\n reported to the \\a grab_window.\n @param grab_window Specifies the window on which the key should be grabbed.\n @param modifiers The modifiers to grab.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means grab the key with all\n possible modifier combinations.\n @param key The keycode of the key to grab.\n \\n\n The special value `XCB_GRAB_ANY` means grab any key.\n @param pointer_mode A bitmask of #xcb_grab_mode_t values.\n @param pointer_mode \\n\n @param keyboard_mode A bitmask of #xcb_grab_mode_t values.\n @param keyboard_mode \\n\n @return A cookie\n\n Establishes a passive grab on the keyboard. In the future, the keyboard is\n actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to\n the time at which the key was pressed (as transmitted in the KeyPress event),\n and the KeyPress event is reported if all of the following conditions are true:\n\n The keyboard is not grabbed and the specified key (which can itself be a\n modifier key) is logically pressed when the specified modifier keys are\n logically down, and no other modifier keys are logically down.\n\n Either the grab_window is an ancestor of (or is) the focus window, or the\n grab_window is a descendant of the focus window and contains the pointer.\n\n A passive grab on the same key combination does not exist on any ancestor of\n grab_window.\n\n The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated\n automatically when the logical state of the keyboard has the specified key released (independent of the\n logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.\n\n Note that the logical state of a device (as seen by client applications) may lag the physical state if\n device event processing is frozen.\n\n A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified\n have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for\n all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode\n and max_keycode in the connection setup, or a BadValue error results.\n\n If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess\n error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error\n results (no grabs are established) if there is a conflicting grab for any combination.\n"]
    pub fn xcb_grab_key(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief release a key combination\n\n @param c The connection\n @param key The keycode of the specified key combination.\n \\n\n Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.\n @param grab_window The window on which the grabbed key combination will be released.\n @param modifiers The modifiers of the specified key combination.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination\n with every possible modifier combination.\n @return A cookie\n\n Releases the key combination on \\a grab_window if you grabbed it using\n `xcb_grab_key` before.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_ungrab_key_checked(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief release a key combination\n\n @param c The connection\n @param key The keycode of the specified key combination.\n \\n\n Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.\n @param grab_window The window on which the grabbed key combination will be released.\n @param modifiers The modifiers of the specified key combination.\n \\n\n Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination\n with every possible modifier combination.\n @return A cookie\n\n Releases the key combination on \\a grab_window if you grabbed it using\n `xcb_grab_key` before.\n"]
    pub fn xcb_ungrab_key(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief release queued events\n\n @param c The connection\n @param mode A bitmask of #xcb_allow_t values.\n @param mode \\n\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Releases queued events if the client has caused a device (pointer/keyboard) to\n freeze due to grabbing it actively. This request has no effect if \\a time is\n earlier than the last-grab time of the most recent active grab for this client\n or if \\a time is later than the current X server time.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_allow_events_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief release queued events\n\n @param c The connection\n @param mode A bitmask of #xcb_allow_t values.\n @param mode \\n\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Releases queued events if the client has caused a device (pointer/keyboard) to\n freeze due to grabbing it actively. This request has no effect if \\a time is\n earlier than the last-grab time of the most recent active grab for this client\n or if \\a time is later than the current X server time.\n"]
    pub fn xcb_allow_events(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief get pointer coordinates\n\n @param c The connection\n @param window A window to check if the pointer is on the same screen as \\a window (see the\n `same_screen` field in the reply).\n @return A cookie\n\n Gets the root window the pointer is logically on and the pointer coordinates\n relative to the root window's origin.\n"]
    pub fn xcb_query_pointer(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    #[doc = " @brief get pointer coordinates\n\n @param c The connection\n @param window A window to check if the pointer is on the same screen as \\a window (see the\n `same_screen` field in the reply).\n @return A cookie\n\n Gets the root window the pointer is logically on and the pointer coordinates\n relative to the root window's origin.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_pointer_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_pointer_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_timecoord_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_timecoord_t)"]
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_timecoord_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_motion_events(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_motion_events_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(
        R: *const xcb_get_motion_events_reply_t,
    ) -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(
        R: *const xcb_get_motion_events_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(
        R: *const xcb_get_motion_events_reply_t,
    ) -> xcb_timecoord_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_motion_events_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_motion_events_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_motion_events_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_translate_coordinates(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_translate_coordinates_unchecked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_translate_coordinates_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_translate_coordinates_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_translate_coordinates_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    #[doc = " @brief move mouse pointer\n\n @param c The connection\n @param src_window If \\a src_window is not `XCB_NONE` (TODO), the move will only take place if the\n pointer is inside \\a src_window and within the rectangle specified by (\\a src_x,\n \\a src_y, \\a src_width, \\a src_height). The rectangle coordinates are relative to\n \\a src_window.\n @param dst_window If \\a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the\n offsets (\\a dst_x, \\a dst_y) relative to \\a dst_window. If \\a dst_window is\n `XCB_NONE` (TODO), the pointer will be moved by the offsets (\\a dst_x, \\a dst_y)\n relative to the current position of the pointer.\n @return A cookie\n\n Moves the mouse pointer to the specified position.\n\n If \\a src_window is not `XCB_NONE` (TODO), the move will only take place if the\n pointer is inside \\a src_window and within the rectangle specified by (\\a src_x,\n \\a src_y, \\a src_width, \\a src_height). The rectangle coordinates are relative to\n \\a src_window.\n\n If \\a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the\n offsets (\\a dst_x, \\a dst_y) relative to \\a dst_window. If \\a dst_window is\n `XCB_NONE` (TODO), the pointer will be moved by the offsets (\\a dst_x, \\a dst_y)\n relative to the current position of the pointer.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_warp_pointer_checked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief move mouse pointer\n\n @param c The connection\n @param src_window If \\a src_window is not `XCB_NONE` (TODO), the move will only take place if the\n pointer is inside \\a src_window and within the rectangle specified by (\\a src_x,\n \\a src_y, \\a src_width, \\a src_height). The rectangle coordinates are relative to\n \\a src_window.\n @param dst_window If \\a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the\n offsets (\\a dst_x, \\a dst_y) relative to \\a dst_window. If \\a dst_window is\n `XCB_NONE` (TODO), the pointer will be moved by the offsets (\\a dst_x, \\a dst_y)\n relative to the current position of the pointer.\n @return A cookie\n\n Moves the mouse pointer to the specified position.\n\n If \\a src_window is not `XCB_NONE` (TODO), the move will only take place if the\n pointer is inside \\a src_window and within the rectangle specified by (\\a src_x,\n \\a src_y, \\a src_width, \\a src_height). The rectangle coordinates are relative to\n \\a src_window.\n\n If \\a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the\n offsets (\\a dst_x, \\a dst_y) relative to \\a dst_window. If \\a dst_window is\n `XCB_NONE` (TODO), the pointer will be moved by the offsets (\\a dst_x, \\a dst_y)\n relative to the current position of the pointer.\n"]
    pub fn xcb_warp_pointer(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Sets input focus\n\n @param c The connection\n @param revert_to A bitmask of #xcb_input_focus_t values.\n @param revert_to Specifies what happens when the \\a focus window becomes unviewable (if \\a focus\n is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).\n @param focus The window to focus. All keyboard events will be reported to this window. The\n window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).\n \\n\n If \\a focus is `XCB_NONE` (TODO), all keyboard events are\n discarded until a new focus window is set.\n \\n\n If \\a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the\n screen on which the pointer is on currently.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Changes the input focus and the last-focus-change time. If the specified \\a time\n is earlier than the current last-focus-change time, the request is ignored (to\n avoid race conditions when running X over the network).\n\n A FocusIn and FocusOut event is generated when focus is changed.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_input_focus_checked(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Sets input focus\n\n @param c The connection\n @param revert_to A bitmask of #xcb_input_focus_t values.\n @param revert_to Specifies what happens when the \\a focus window becomes unviewable (if \\a focus\n is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).\n @param focus The window to focus. All keyboard events will be reported to this window. The\n window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).\n \\n\n If \\a focus is `XCB_NONE` (TODO), all keyboard events are\n discarded until a new focus window is set.\n \\n\n If \\a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the\n screen on which the pointer is on currently.\n @param time Timestamp to avoid race conditions when running X over the network.\n \\n\n The special value `XCB_CURRENT_TIME` will be replaced with the current server\n time.\n @return A cookie\n\n Changes the input focus and the last-focus-change time. If the specified \\a time\n is earlier than the current last-focus-change time, the request is ignored (to\n avoid race conditions when running X over the network).\n\n A FocusIn and FocusOut event is generated when focus is changed.\n"]
    pub fn xcb_set_input_focus(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_input_focus_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_input_focus_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_input_focus_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_query_keymap(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_keymap_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_keymap_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_keymap_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief opens a font\n\n @param c The connection\n @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.\n @param name_len Length (in bytes) of \\a name.\n @param name A pattern describing an X core font.\n @return A cookie\n\n Opens any X core font matching the given \\a name (for example \"-misc-fixed-*\").\n\n Note that X core fonts are deprecated (but still supported) in favor of\n client-side rendering using Xft.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_open_font_checked(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief opens a font\n\n @param c The connection\n @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.\n @param name_len Length (in bytes) of \\a name.\n @param name A pattern describing an X core font.\n @return A cookie\n\n Opens any X core font matching the given \\a name (for example \"-misc-fixed-*\").\n\n Note that X core fonts are deprecated (but still supported) in favor of\n client-side rendering using Xft.\n"]
    pub fn xcb_open_font(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_fontprop_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_fontprop_t)"]
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_fontprop_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_charinfo_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_charinfo_t)"]
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_charinfo_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief query font metrics\n\n @param c The connection\n @param font The fontable (Font or Graphics Context) to query.\n @return A cookie\n\n Queries information associated with the font.\n"]
    pub fn xcb_query_font(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    #[doc = " @brief query font metrics\n\n @param c The connection\n @param font The fontable (Font or Graphics Context) to query.\n @return A cookie\n\n Queries information associated with the font.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_font_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t) -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_charinfo_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_font_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_font_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_font_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        string_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief get text extents\n\n @param c The connection\n @param font The \\a font to calculate text extents in. You can also pass a graphics context.\n @param string_len The number of characters in \\a string.\n @param string The text to get text extents for.\n @return A cookie\n\n Query text extents from the X11 server. This request returns the bounding box\n of the specified 16-bit character string in the specified \\a font or the font\n contained in the specified graphics context.\n\n `font_ascent` is set to the maximum of the ascent metrics of all characters in\n the string. `font_descent` is set to the maximum of the descent metrics.\n `overall_width` is set to the sum of the character-width metrics of all\n characters in the string. For each character in the string, let W be the sum of\n the character-width metrics of all characters preceding it in the string. Let L\n be the left-side-bearing metric of the character plus W. Let R be the\n right-side-bearing metric of the character plus W. The lbearing member is set\n to the minimum L of all characters in the string. The rbearing member is set to\n the maximum R.\n\n For fonts defined with linear indexing rather than 2-byte matrix indexing, each\n `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the\n most significant byte. If the font has no defined default character, undefined\n characters in the string are taken to have all zero metrics.\n\n Characters with all zero metrics are ignored. If the font has no defined\n default_char, the undefined characters in the string are also ignored.\n"]
    pub fn xcb_query_text_extents(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    #[doc = " @brief get text extents\n\n @param c The connection\n @param font The \\a font to calculate text extents in. You can also pass a graphics context.\n @param string_len The number of characters in \\a string.\n @param string The text to get text extents for.\n @return A cookie\n\n Query text extents from the X11 server. This request returns the bounding box\n of the specified 16-bit character string in the specified \\a font or the font\n contained in the specified graphics context.\n\n `font_ascent` is set to the maximum of the ascent metrics of all characters in\n the string. `font_descent` is set to the maximum of the descent metrics.\n `overall_width` is set to the sum of the character-width metrics of all\n characters in the string. For each character in the string, let W be the sum of\n the character-width metrics of all characters preceding it in the string. Let L\n be the left-side-bearing metric of the character plus W. Let R be the\n right-side-bearing metric of the character plus W. The lbearing member is set\n to the minimum L of all characters in the string. The rbearing member is set to\n the maximum R.\n\n For fonts defined with linear indexing rather than 2-byte matrix indexing, each\n `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the\n most significant byte. If the font has no defined default character, undefined\n characters in the string are taken to have all zero metrics.\n\n Characters with all zero metrics are ignored. If the font has no defined\n default_char, the undefined characters in the string are also ignored.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_text_extents_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_text_extents_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_text_extents_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_text_extents_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_str_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_str_t)"]
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_str_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief get matching font names\n\n @param c The connection\n @param max_names The maximum number of fonts to be returned.\n @param pattern_len The length (in bytes) of \\a pattern.\n @param pattern A font pattern, for example \"-misc-fixed-*\".\n \\n\n The asterisk (*) is a wildcard for any number of characters. The question mark\n (?) is a wildcard for a single character. Use of uppercase or lowercase does\n not matter.\n @return A cookie\n\n Gets a list of available font names which match the given \\a pattern.\n"]
    pub fn xcb_list_fonts(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    #[doc = " @brief get matching font names\n\n @param c The connection\n @param max_names The maximum number of fonts to be returned.\n @param pattern_len The length (in bytes) of \\a pattern.\n @param pattern A font pattern, for example \"-misc-fixed-*\".\n \\n\n The asterisk (*) is a wildcard for any number of characters. The question mark\n (?) is a wildcard for a single character. Use of uppercase or lowercase does\n not matter.\n @return A cookie\n\n Gets a list of available font names which match the given \\a pattern.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_fonts_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t) -> xcb_str_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_fonts_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_fonts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief get matching font names and information\n\n @param c The connection\n @param max_names The maximum number of fonts to be returned.\n @param pattern_len The length (in bytes) of \\a pattern.\n @param pattern A font pattern, for example \"-misc-fixed-*\".\n \\n\n The asterisk (*) is a wildcard for any number of characters. The question mark\n (?) is a wildcard for a single character. Use of uppercase or lowercase does\n not matter.\n @return A cookie\n\n Gets a list of available font names which match the given \\a pattern.\n"]
    pub fn xcb_list_fonts_with_info(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    #[doc = " @brief get matching font names and information\n\n @param c The connection\n @param max_names The maximum number of fonts to be returned.\n @param pattern_len The length (in bytes) of \\a pattern.\n @param pattern A font pattern, for example \"-misc-fixed-*\".\n \\n\n The asterisk (*) is a wildcard for any number of characters. The question mark\n (?) is a wildcard for a single character. Use of uppercase or lowercase does\n not matter.\n @return A cookie\n\n Gets a list of available font names which match the given \\a pattern.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_fonts_with_info_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_fonts_with_info_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_fonts_with_info_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_with_info_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_font_path_checked(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_font_path(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(
        R: *const xcb_set_font_path_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(
        R: *const xcb_set_font_path_request_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_font_path(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(
        R: *const xcb_get_font_path_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(
        R: *const xcb_get_font_path_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_font_path_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_font_path_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_font_path_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    #[doc = " @brief Creates a pixmap\n\n @param c The connection\n @param depth TODO\n @param pid The ID with which you will refer to the new pixmap, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the screen from.\n @param width The width of the new pixmap.\n @param height The height of the new pixmap.\n @return A cookie\n\n Creates a pixmap. The pixmap can only be used on the same screen as \\a drawable\n is on and only with drawables of the same \\a depth.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_pixmap_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a pixmap\n\n @param c The connection\n @param depth TODO\n @param pid The ID with which you will refer to the new pixmap, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the screen from.\n @param width The width of the new pixmap.\n @param height The height of the new pixmap.\n @return A cookie\n\n Creates a pixmap. The pixmap can only be used on the same screen as \\a drawable\n is on and only with drawables of the same \\a depth.\n"]
    pub fn xcb_create_pixmap(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Destroys a pixmap\n\n @param c The connection\n @param pixmap The pixmap to destroy.\n @return A cookie\n\n Deletes the association between the pixmap ID and the pixmap. The pixmap\n storage will be freed when there are no more references to it.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_free_pixmap_checked(
        c: *mut xcb_connection_t,
        pixmap: xcb_pixmap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Destroys a pixmap\n\n @param c The connection\n @param pixmap The pixmap to destroy.\n @return A cookie\n\n Deletes the association between the pixmap ID and the pixmap. The pixmap\n storage will be freed when there are no more references to it.\n"]
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates a graphics context\n\n @param c The connection\n @param cid The ID with which you will refer to the graphics context, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the root/depth from.\n @return A cookie\n\n Creates a graphics context. The graphics context can be used with any drawable\n that has the same root and depth as the specified drawable.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_gc_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a graphics context\n\n @param c The connection\n @param cid The ID with which you will refer to the graphics context, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the root/depth from.\n @return A cookie\n\n Creates a graphics context. The graphics context can be used with any drawable\n that has the same root and depth as the specified drawable.\n"]
    pub fn xcb_create_gc(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a graphics context\n\n @param c The connection\n @param cid The ID with which you will refer to the graphics context, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the root/depth from.\n @return A cookie\n\n Creates a graphics context. The graphics context can be used with any drawable\n that has the same root and depth as the specified drawable.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_gc_aux_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Creates a graphics context\n\n @param c The connection\n @param cid The ID with which you will refer to the graphics context, created by\n `xcb_generate_id`.\n @param drawable Drawable to get the root/depth from.\n @return A cookie\n\n Creates a graphics context. The graphics context can be used with any drawable\n that has the same root and depth as the specified drawable.\n"]
    pub fn xcb_create_gc_aux(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(
        R: *const xcb_create_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief change graphics context components\n\n @param c The connection\n @param gc The graphics context to change.\n @param value_mask A bitmask of #xcb_gc_t values.\n @param value_mask \\n\n @param value_list Values for each of the components specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the components specified by \\a value_mask for the specified graphics context.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_gc_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change graphics context components\n\n @param c The connection\n @param gc The graphics context to change.\n @param value_mask A bitmask of #xcb_gc_t values.\n @param value_mask \\n\n @param value_list Values for each of the components specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the components specified by \\a value_mask for the specified graphics context.\n"]
    pub fn xcb_change_gc(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change graphics context components\n\n @param c The connection\n @param gc The graphics context to change.\n @param value_mask A bitmask of #xcb_gc_t values.\n @param value_mask \\n\n @param value_list Values for each of the components specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the components specified by \\a value_mask for the specified graphics context.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_gc_aux_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief change graphics context components\n\n @param c The connection\n @param gc The graphics context to change.\n @param value_mask A bitmask of #xcb_gc_t values.\n @param value_mask \\n\n @param value_list Values for each of the components specified in the bitmask \\a value_mask. The\n order has to correspond to the order of possible \\a value_mask bits. See the\n example.\n @return A cookie\n\n Changes the components specified by \\a value_mask for the specified graphics context.\n"]
    pub fn xcb_change_gc_aux(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(
        R: *const xcb_change_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_copy_gc_checked(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_copy_gc(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_dashes_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_dashes(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(
        R: *const xcb_set_dashes_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_clip_rectangles_checked(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_clip_rectangles(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    #[doc = " @brief Destroys a graphics context\n\n @param c The connection\n @param gc The graphics context to destroy.\n @return A cookie\n\n Destroys the specified \\a gc and all associated storage.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Destroys a graphics context\n\n @param c The connection\n @param gc The graphics context to destroy.\n @return A cookie\n\n Destroys the specified \\a gc and all associated storage.\n"]
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_clear_area_checked(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_clear_area(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief copy areas\n\n @param c The connection\n @param src_drawable The source drawable (Window or Pixmap).\n @param dst_drawable The destination drawable (Window or Pixmap).\n @param gc The graphics context to use.\n @param src_x The source X coordinate.\n @param src_y The source Y coordinate.\n @param dst_x The destination X coordinate.\n @param dst_y The destination Y coordinate.\n @param width The width of the area to copy (in pixels).\n @param height The height of the area to copy (in pixels).\n @return A cookie\n\n Copies the specified rectangle from \\a src_drawable to \\a dst_drawable.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_copy_area_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief copy areas\n\n @param c The connection\n @param src_drawable The source drawable (Window or Pixmap).\n @param dst_drawable The destination drawable (Window or Pixmap).\n @param gc The graphics context to use.\n @param src_x The source X coordinate.\n @param src_y The source Y coordinate.\n @param dst_x The destination X coordinate.\n @param dst_y The destination Y coordinate.\n @param width The width of the area to copy (in pixels).\n @param height The height of the area to copy (in pixels).\n @return A cookie\n\n Copies the specified rectangle from \\a src_drawable to \\a dst_drawable.\n"]
    pub fn xcb_copy_area(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_copy_plane_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_copy_plane(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_point_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_point(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(
        R: *const xcb_poly_point_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(
        R: *const xcb_poly_point_request_t,
    ) -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief draw lines\n\n @param c The connection\n @param coordinate_mode A bitmask of #xcb_coord_mode_t values.\n @param coordinate_mode \\n\n @param drawable The drawable to draw the line(s) on.\n @param gc The graphics context to use.\n @param points_len The number of `xcb_point_t` structures in \\a points.\n @param points An array of points.\n @return A cookie\n\n Draws \\a points_len-1 lines between each pair of points (point[i], point[i+1])\n in the \\a points array. The lines are drawn in the order listed in the array.\n They join correctly at all intermediate points, and if the first and last\n points coincide, the first and last lines also join correctly. For any given\n line, a pixel is not drawn more than once. If thin (zero line-width) lines\n intersect, the intersecting pixels are drawn multiple times. If wide lines\n intersect, the intersecting pixels are drawn only once, as though the entire\n request were a single, filled shape.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_line_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief draw lines\n\n @param c The connection\n @param coordinate_mode A bitmask of #xcb_coord_mode_t values.\n @param coordinate_mode \\n\n @param drawable The drawable to draw the line(s) on.\n @param gc The graphics context to use.\n @param points_len The number of `xcb_point_t` structures in \\a points.\n @param points An array of points.\n @return A cookie\n\n Draws \\a points_len-1 lines between each pair of points (point[i], point[i+1])\n in the \\a points array. The lines are drawn in the order listed in the array.\n They join correctly at all intermediate points, and if the first and last\n points coincide, the first and last lines also join correctly. For any given\n line, a pixel is not drawn more than once. If thin (zero line-width) lines\n intersect, the intersecting pixels are drawn multiple times. If wide lines\n intersect, the intersecting pixels are drawn only once, as though the entire\n request were a single, filled shape.\n"]
    pub fn xcb_poly_line(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_segment_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_segment_t)"]
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_segment_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_segment_end(i: xcb_segment_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        segments_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief draw lines\n\n @param c The connection\n @param drawable A drawable (Window or Pixmap) to draw on.\n @param gc The graphics context to use.\n \\n\n TODO: document which attributes of a gc are used\n @param segments_len The number of `xcb_segment_t` structures in \\a segments.\n @param segments An array of `xcb_segment_t` structures.\n @return A cookie\n\n Draws multiple, unconnected lines. For each segment, a line is drawn between\n (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of\n `xcb_segment_t` structures and does not perform joining at coincident\n endpoints. For any given line, a pixel is not drawn more than once. If lines\n intersect, the intersecting pixels are drawn multiple times.\n\n TODO: include the xcb_segment_t data structure\n\n TODO: an example\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_segment_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief draw lines\n\n @param c The connection\n @param drawable A drawable (Window or Pixmap) to draw on.\n @param gc The graphics context to use.\n \\n\n TODO: document which attributes of a gc are used\n @param segments_len The number of `xcb_segment_t` structures in \\a segments.\n @param segments An array of `xcb_segment_t` structures.\n @return A cookie\n\n Draws multiple, unconnected lines. For each segment, a line is drawn between\n (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of\n `xcb_segment_t` structures and does not perform joining at coincident\n endpoints. For any given line, a pixel is not drawn more than once. If lines\n intersect, the intersecting pixels are drawn multiple times.\n\n TODO: include the xcb_segment_t data structure\n\n TODO: an example\n"]
    pub fn xcb_poly_segment(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t) -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(
        R: *const xcb_poly_segment_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(
        R: *const xcb_poly_segment_request_t,
    ) -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(
        R: *const xcb_poly_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(
        R: *const xcb_poly_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(
        R: *const xcb_poly_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_fill_poly_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_fill_poly(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fills rectangles\n\n @param c The connection\n @param drawable The drawable (Window or Pixmap) to draw on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: function, plane-mask,\n fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n \\n\n The following graphics context mode-dependent components are used:\n foreground, background, tile, stipple, tile-stipple-x-origin, and\n tile-stipple-y-origin.\n @param rectangles_len The number of `xcb_rectangle_t` structures in \\a rectangles.\n @param rectangles The rectangles to fill.\n @return A cookie\n\n Fills the specified rectangle(s) in the order listed in the array. For any\n given rectangle, each pixel is not drawn more than once. If rectangles\n intersect, the intersecting pixels are drawn multiple times.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_fill_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Fills rectangles\n\n @param c The connection\n @param drawable The drawable (Window or Pixmap) to draw on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: function, plane-mask,\n fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n \\n\n The following graphics context mode-dependent components are used:\n foreground, background, tile, stipple, tile-stipple-x-origin, and\n tile-stipple-y-origin.\n @param rectangles_len The number of `xcb_rectangle_t` structures in \\a rectangles.\n @param rectangles The rectangles to fill.\n @return A cookie\n\n Fills the specified rectangle(s) in the order listed in the array. For any\n given rectangle, each pixel is not drawn more than once. If rectangles\n intersect, the intersecting pixels are drawn multiple times.\n"]
    pub fn xcb_poly_fill_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_fill_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_fill_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        data_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_put_image_checked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_put_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_image_unchecked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_image_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_image_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_image_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_text_8_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_text_8(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(
        R: *const xcb_poly_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_poly_text_16_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_poly_text_16(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(
        R: *const xcb_poly_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(
        R: *const xcb_poly_text_16_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Draws text\n\n @param c The connection\n @param string_len The length of the \\a string. Note that this parameter limited by 255 due to\n using 8 bits!\n @param drawable The drawable (Window or Pixmap) to draw text on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: plane-mask, foreground,\n background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n @param x The x coordinate of the first character, relative to the origin of \\a drawable.\n @param y The y coordinate of the first character, relative to the origin of \\a drawable.\n @param string The string to draw. Only the first 255 characters are relevant due to the data\n type of \\a string_len.\n @return A cookie\n\n Fills the destination rectangle with the background pixel from \\a gc, then\n paints the text with the foreground pixel from \\a gc. The upper-left corner of\n the filled rectangle is at [x, y - font-ascent]. The width is overall-width,\n the height is font-ascent + font-descent. The overall-width, font-ascent and\n font-descent are as returned by `xcb_query_text_extents` (TODO).\n\n Note that using X core fonts is deprecated (but still supported) in favor of\n client-side rendering using Xft.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_image_text_8_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Draws text\n\n @param c The connection\n @param string_len The length of the \\a string. Note that this parameter limited by 255 due to\n using 8 bits!\n @param drawable The drawable (Window or Pixmap) to draw text on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: plane-mask, foreground,\n background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n @param x The x coordinate of the first character, relative to the origin of \\a drawable.\n @param y The y coordinate of the first character, relative to the origin of \\a drawable.\n @param string The string to draw. Only the first 255 characters are relevant due to the data\n type of \\a string_len.\n @return A cookie\n\n Fills the destination rectangle with the background pixel from \\a gc, then\n paints the text with the foreground pixel from \\a gc. The upper-left corner of\n the filled rectangle is at [x, y - font-ascent]. The width is overall-width,\n the height is font-ascent + font-descent. The overall-width, font-ascent and\n font-descent are as returned by `xcb_query_text_extents` (TODO).\n\n Note that using X core fonts is deprecated (but still supported) in favor of\n client-side rendering using Xft.\n"]
    pub fn xcb_image_text_8(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(
        R: *const xcb_image_text_8_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(
        R: *const xcb_image_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(
        R: *const xcb_image_text_8_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Draws text\n\n @param c The connection\n @param string_len The length of the \\a string in characters. Note that this parameter limited by\n 255 due to using 8 bits!\n @param drawable The drawable (Window or Pixmap) to draw text on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: plane-mask, foreground,\n background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n @param x The x coordinate of the first character, relative to the origin of \\a drawable.\n @param y The y coordinate of the first character, relative to the origin of \\a drawable.\n @param string The string to draw. Only the first 255 characters are relevant due to the data\n type of \\a string_len. Every character uses 2 bytes (hence the 16 in this\n request's name).\n @return A cookie\n\n Fills the destination rectangle with the background pixel from \\a gc, then\n paints the text with the foreground pixel from \\a gc. The upper-left corner of\n the filled rectangle is at [x, y - font-ascent]. The width is overall-width,\n the height is font-ascent + font-descent. The overall-width, font-ascent and\n font-descent are as returned by `xcb_query_text_extents` (TODO).\n\n Note that using X core fonts is deprecated (but still supported) in favor of\n client-side rendering using Xft.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_image_text_16_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Draws text\n\n @param c The connection\n @param string_len The length of the \\a string in characters. Note that this parameter limited by\n 255 due to using 8 bits!\n @param drawable The drawable (Window or Pixmap) to draw text on.\n @param gc The graphics context to use.\n \\n\n The following graphics context components are used: plane-mask, foreground,\n background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.\n @param x The x coordinate of the first character, relative to the origin of \\a drawable.\n @param y The y coordinate of the first character, relative to the origin of \\a drawable.\n @param string The string to draw. Only the first 255 characters are relevant due to the data\n type of \\a string_len. Every character uses 2 bytes (hence the 16 in this\n request's name).\n @return A cookie\n\n Fills the destination rectangle with the background pixel from \\a gc, then\n paints the text with the foreground pixel from \\a gc. The upper-left corner of\n the filled rectangle is at [x, y - font-ascent]. The width is overall-width,\n the height is font-ascent + font-descent. The overall-width, font-ascent and\n font-descent are as returned by `xcb_query_text_extents` (TODO).\n\n Note that using X core fonts is deprecated (but still supported) in favor of\n client-side rendering using Xft.\n"]
    pub fn xcb_image_text_16(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t) -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(
        R: *const xcb_image_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(
        R: *const xcb_image_text_16_request_t,
    ) -> xcb_char2b_iterator_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_colormap_checked(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_create_colormap(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_free_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_copy_colormap_and_free_checked(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_copy_colormap_and_free(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_install_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_install_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_uninstall_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_uninstall_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_list_installed_colormaps(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_installed_colormaps_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_installed_colormaps_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_installed_colormaps_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_installed_colormaps_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    #[doc = " @brief Allocate a color\n\n @param c The connection\n @param cmap TODO\n @param red The red value of your color.\n @param green The green value of your color.\n @param blue The blue value of your color.\n @return A cookie\n\n Allocates a read-only colormap entry corresponding to the closest RGB value\n supported by the hardware. If you are using TrueColor, you can take a shortcut\n and directly calculate the color pixel value to avoid the round trip. But, for\n example, on 16-bit color setups (VNC), you can easily get the closest supported\n RGB value to the RGB value you are specifying.\n"]
    pub fn xcb_alloc_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    #[doc = " @brief Allocate a color\n\n @param c The connection\n @param cmap TODO\n @param red The red value of your color.\n @param green The green value of your color.\n @param blue The blue value of your color.\n @return A cookie\n\n Allocates a read-only colormap entry corresponding to the closest RGB value\n supported by the hardware. If you are using TrueColor, you can take a shortcut\n and directly calculate the color pixel value to avoid the round trip. But, for\n example, on 16-bit color setups (VNC), you can easily get the closest supported\n RGB value to the RGB value you are specifying.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_alloc_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_alloc_color_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_alloc_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_alloc_named_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_alloc_named_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_alloc_named_color_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_alloc_named_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_named_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_alloc_color_cells(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_alloc_color_cells_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_alloc_color_cells_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_alloc_color_cells_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cells_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_alloc_color_planes(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_alloc_color_planes_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R: *const xcb_alloc_color_planes_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_alloc_color_planes_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_alloc_color_planes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_planes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_free_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_free_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(
        R: *const xcb_free_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(
        R: *const xcb_free_colors_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_coloritem_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_coloritem_t)"]
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_coloritem_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_store_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_store_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t) -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(
        R: *const xcb_store_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(
        R: *const xcb_store_colors_request_t,
    ) -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_store_named_color_checked(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_store_named_color(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(
        R: *const xcb_store_named_color_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(
        R: *const xcb_store_named_color_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(
        R: *const xcb_store_named_color_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_rgb_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_rgb_t)"]
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_rgb_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_query_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_colors_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t) -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(
        R: *const xcb_query_colors_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(
        R: *const xcb_query_colors_reply_t,
    ) -> xcb_rgb_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_colors_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_colors_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_colors_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_lookup_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_lookup_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_lookup_color_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_lookup_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_lookup_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_create_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief create cursor\n\n @param c The connection\n @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.\n @param source_font In which font to look for the cursor glyph.\n @param mask_font In which font to look for the mask glyph.\n @param source_char The glyph of \\a source_font to use.\n @param mask_char The glyph of \\a mask_font to use as a mask: Pixels which are set to 1 define\n which source pixels are displayed. All pixels which are set to 0 are not\n displayed.\n @param fore_red The red value of the foreground color.\n @param fore_green The green value of the foreground color.\n @param fore_blue The blue value of the foreground color.\n @param back_red The red value of the background color.\n @param back_green The green value of the background color.\n @param back_blue The blue value of the background color.\n @return A cookie\n\n Creates a cursor from a font glyph. X provides a set of standard cursor shapes\n in a special font named cursor. Applications are encouraged to use this\n interface for their cursors because the font can be customized for the\n individual display type.\n\n All pixels which are set to 1 in the source will use the foreground color (as\n specified by \\a fore_red, \\a fore_green and \\a fore_blue). All pixels set to 0\n will use the background color (as specified by \\a back_red, \\a back_green and\n \\a back_blue).\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_create_glyph_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief create cursor\n\n @param c The connection\n @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.\n @param source_font In which font to look for the cursor glyph.\n @param mask_font In which font to look for the mask glyph.\n @param source_char The glyph of \\a source_font to use.\n @param mask_char The glyph of \\a mask_font to use as a mask: Pixels which are set to 1 define\n which source pixels are displayed. All pixels which are set to 0 are not\n displayed.\n @param fore_red The red value of the foreground color.\n @param fore_green The green value of the foreground color.\n @param fore_blue The blue value of the foreground color.\n @param back_red The red value of the background color.\n @param back_green The green value of the background color.\n @param back_blue The blue value of the background color.\n @return A cookie\n\n Creates a cursor from a font glyph. X provides a set of standard cursor shapes\n in a special font named cursor. Applications are encouraged to use this\n interface for their cursors because the font can be customized for the\n individual display type.\n\n All pixels which are set to 1 in the source will use the foreground color (as\n specified by \\a fore_red, \\a fore_green and \\a fore_blue). All pixels set to 0\n will use the background color (as specified by \\a back_red, \\a back_green and\n \\a back_blue).\n"]
    pub fn xcb_create_glyph_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Deletes a cursor\n\n @param c The connection\n @param cursor The cursor to destroy.\n @return A cookie\n\n Deletes the association between the cursor resource ID and the specified\n cursor. The cursor is freed when no other resource references it.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_free_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief Deletes a cursor\n\n @param c The connection\n @param cursor The cursor to destroy.\n @return A cookie\n\n Deletes the association between the cursor resource ID and the specified\n cursor. The cursor is freed when no other resource references it.\n"]
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_recolor_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_recolor_cursor(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_query_best_size(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_best_size_unchecked(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_best_size_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_best_size_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_best_size_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief check if extension is present\n\n @param c The connection\n @param name_len The length of \\a name in bytes.\n @param name The name of the extension to query, for example \"RANDR\". This is case\n sensitive!\n @return A cookie\n\n Determines if the specified extension is present on this X11 server.\n\n Every extension has a unique `major_opcode` to identify requests, the minor\n opcodes and request formats are extension-specific. If the extension provides\n events and errors, the `first_event` and `first_error` fields in the reply are\n set accordingly.\n\n There should rarely be a need to use this request directly, XCB provides the\n `xcb_get_extension_data` function instead.\n"]
    pub fn xcb_query_extension(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    #[doc = " @brief check if extension is present\n\n @param c The connection\n @param name_len The length of \\a name in bytes.\n @param name The name of the extension to query, for example \"RANDR\". This is case\n sensitive!\n @return A cookie\n\n Determines if the specified extension is present on this X11 server.\n\n Every extension has a unique `major_opcode` to identify requests, the minor\n opcodes and request formats are extension-specific. If the extension provides\n events and errors, the `first_event` and `first_error` fields in the reply are\n set accordingly.\n\n There should rarely be a need to use this request directly, XCB provides the\n `xcb_get_extension_data` function instead.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_query_extension_unchecked(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_query_extension_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_query_extension_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_extension_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_list_extensions(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(
        R: *const xcb_list_extensions_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(
        R: *const xcb_list_extensions_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_extensions_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_extensions_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_extensions_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_keyboard_mapping_checked(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_keyboard_mapping(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_keyboard_mapping(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_keyboard_mapping_unchecked(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_keyboard_mapping_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_keyboard_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_keyboard_control_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_keyboard_control(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_keyboard_control_aux_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_keyboard_control_aux(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(
        R: *const xcb_change_keyboard_control_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_keyboard_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_keyboard_control_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_keyboard_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_pointer_control_checked(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_pointer_control(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_pointer_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_pointer_control_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_pointer_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_screen_saver_checked(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_screen_saver(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_screen_saver_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_screen_saver_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_screen_saver_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_screen_saver_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_change_hosts_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_change_hosts(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(
        R: *const xcb_change_hosts_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(
        R: *const xcb_change_hosts_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Get the next element of the iterator\n @param i Pointer to a xcb_host_iterator_t\n\n Get the next element in the iterator. The member rem is\n decreased by one. The member data points to the next\n element. The member index is increased by sizeof(xcb_host_t)"]
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    #[doc = " Return the iterator pointing to the last element\n @param i An xcb_host_iterator_t\n @return  The iterator pointing to the last element\n\n Set the current element in the iterator to the last element.\n The member rem is set to 0. The member data points to the\n last element."]
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_list_hosts(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t) -> xcb_host_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_list_hosts_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_list_hosts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_hosts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
        -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief kills a client\n\n @param c The connection\n @param resource Any resource belonging to the client (for example a Window), used to identify\n the client connection.\n \\n\n The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients\n that have terminated in `RetainTemporary` (TODO) are destroyed.\n @return A cookie\n\n Forces a close down of the client that created the specified \\a resource.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @brief kills a client\n\n @param c The connection\n @param resource Any resource belonging to the client (for example a Window), used to identify\n the client connection.\n \\n\n The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients\n that have terminated in `RetainTemporary` (TODO) are destroyed.\n @return A cookie\n\n Forces a close down of the client that created the specified \\a resource.\n"]
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_rotate_properties_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_rotate_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(
        R: *const xcb_rotate_properties_request_t,
    ) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(
        R: *const xcb_rotate_properties_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(
        R: *const xcb_rotate_properties_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_pointer_mapping(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_set_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_set_pointer_mapping_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_set_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R: *const xcb_get_pointer_mapping_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_pointer_mapping_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_set_modifier_mapping(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_set_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_set_modifier_mapping_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_set_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will cause\n a reply to be generated. Any returned error will be\n placed in the event queue."]
    pub fn xcb_get_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    #[doc = " Return the reply\n @param c      The connection\n @param cookie The cookie\n @param e      The xcb_generic_error_t supplied\n\n Returns the reply of the request asked by\n\n The parameter @p e supplied to this function must be NULL if\n xcb_get_modifier_mapping_unchecked(). is used.\n Otherwise, it stores the error if any.\n\n The returned value must be freed by the caller using free()."]
    pub fn xcb_get_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n\n This form can be used only if the request will not cause\n a reply to be generated. Any returned error will be\n saved for handling by xcb_request_check()."]
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    #[doc = " @param c The connection\n @return A cookie\n\n Delivers a request to the X server.\n"]
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[doc = " @brief Container for authorization information.\n\n A container for authorization information to be sent to the X server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_auth_info_t {
    #[doc = "< Length of the string name (as returned by strlen)."]
    pub namelen: ::std::os::raw::c_int,
    #[doc = "< String containing the authentication protocol name, such as \"MIT-MAGIC-COOKIE-1\" or \"XDM-AUTHORIZATION-1\"."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Length of the data member."]
    pub datalen: ::std::os::raw::c_int,
    #[doc = "< Data interpreted in a protocol-specific manner."]
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<xcb_auth_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcb_auth_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_auth_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " @brief Forces any buffered output to be written to the server.\n @param c The connection to the X server.\n @return > @c 0 on success, <= @c 0 otherwise.\n\n Forces any buffered output to be written to the server. Blocks\n until the write is complete."]
    pub fn xcb_flush(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the maximum request length that this server accepts.\n @param c The connection to the X server.\n @return The maximum request length field.\n\n In the absence of the BIG-REQUESTS extension, returns the\n maximum request length field from the connection setup data, which\n may be as much as 65535. If the server supports BIG-REQUESTS, then\n the maximum request length field from the reply to the\n BigRequestsEnable request will be returned instead.\n\n Note that this length is measured in four-byte units, making the\n theoretical maximum lengths roughly 256kB without BIG-REQUESTS and\n 16GB with."]
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    #[doc = " @brief Prefetch the maximum request length without blocking.\n @param c The connection to the X server.\n\n Without blocking, does as much work as possible toward computing\n the maximum request length accepted by the X server.\n\n Invoking this function may cause a call to xcb_big_requests_enable,\n but will not block waiting for the reply.\n xcb_get_maximum_request_length will return the prefetched data\n after possibly blocking while the reply is retrieved.\n\n Note that in order for this function to be fully non-blocking, the\n application must previously have called\n xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply\n must have already arrived."]
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    #[doc = " @brief Returns the next event or error from the server.\n @param c The connection to the X server.\n @return The next event from the server.\n\n Returns the next event or error from the server, or returns null in\n the event of an I/O error. Blocks until either an event or error\n arrive, or an I/O error occurs."]
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    #[doc = " @brief Returns the next event or error from the server.\n @param c The connection to the X server.\n @return The next event from the server.\n\n Returns the next event or error from the server, if one is\n available, or returns @c NULL otherwise. If no event is available, that\n might be because an I/O error like connection close occurred while\n attempting to read the next event, in which case the connection is\n shut down when this function returns."]
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    #[doc = " @brief Returns the next event without reading from the connection.\n @param c The connection to the X server.\n @return The next already queued event from the server.\n\n This is a version of xcb_poll_for_event that only examines the\n event queue for new events. The function doesn't try to read new\n events from the connection if no queued events are found.\n\n This function is useful for callers that know in advance that all\n interesting events have already been read from the connection. For\n example, callers might use xcb_wait_for_reply and be interested\n only of events that preceded a specific reply."]
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event {
    _unused: [u8; 0],
}
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    #[doc = " @brief Returns the next event from a special queue"]
    pub fn xcb_poll_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
extern "C" {
    #[doc = " @brief Returns the next event from a special queue, blocking until one arrives"]
    pub fn xcb_wait_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Listen for a special event"]
    pub fn xcb_register_for_special_xge(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
        eid: u32,
        stamp: *mut u32,
    ) -> *mut xcb_special_event_t;
}
extern "C" {
    #[doc = " @brief Stop listening for a special event"]
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t, se: *mut xcb_special_event_t);
}
extern "C" {
    #[doc = " @brief Return the error for a request, or NULL if none can ever arrive.\n @param c The connection to the X server.\n @param cookie The request cookie.\n @return The error for the request, or NULL if none can ever arrive.\n\n The xcb_void_cookie_t cookie supplied to this function must have resulted\n from a call to xcb_[request_name]_checked().  This function will block\n until one of two conditions happens.  If an error is received, it will be\n returned.  If a reply to a subsequent request has already arrived, no error\n can arrive for this request, so this function will return NULL.\n\n Note that this function will perform a sync if needed to ensure that the\n sequence number will advance beyond that provided in cookie; this is a\n convenience to avoid races in determining whether the sync is needed."]
    pub fn xcb_request_check(
        c: *mut xcb_connection_t,
        cookie: xcb_void_cookie_t,
    ) -> *mut xcb_generic_error_t;
}
extern "C" {
    #[doc = " @brief Discards the reply for a request.\n @param c The connection to the X server.\n @param sequence The request sequence number from a cookie.\n\n Discards the reply for a request. Additionally, any error generated\n by the request is also discarded (unless it was an _unchecked request\n and the error has already arrived).\n\n This function will not block even if the reply is not yet available.\n\n Note that the sequence really does have to come from an xcb cookie;\n this function is not designed to operate on socket-handoff replies."]
    pub fn xcb_discard_reply(c: *mut xcb_connection_t, sequence: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @brief Discards the reply for a request, given by a 64bit sequence number\n @param c The connection to the X server.\n @param sequence 64-bit sequence number as returned by xcb_send_request64().\n\n Discards the reply for a request. Additionally, any error generated\n by the request is also discarded (unless it was an _unchecked request\n and the error has already arrived).\n\n This function will not block even if the reply is not yet available.\n\n Note that the sequence really does have to come from xcb_send_request64();\n the cookie sequence number is defined as \"unsigned\" int and therefore\n not 64-bit on all platforms.\n This function is not designed to operate on socket-handoff replies.\n\n Unlike its xcb_discard_reply() counterpart, the given sequence number is not\n automatically \"widened\" to 64-bit."]
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    #[doc = " @brief Caches reply information from QueryExtension requests.\n @param c The connection.\n @param ext The extension data.\n @return A pointer to the xcb_query_extension_reply_t for the extension.\n\n This function is the primary interface to the \"extension cache\",\n which caches reply information from QueryExtension\n requests. Invoking this function may cause a call to\n xcb_query_extension to retrieve extension information from the\n server, and may block until extension data is received from the\n server.\n\n The result must not be freed. This storage is managed by the cache\n itself."]
    pub fn xcb_get_extension_data(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
    ) -> *const xcb_query_extension_reply_t;
}
extern "C" {
    #[doc = " @brief Prefetch of extension data into the extension cache\n @param c The connection.\n @param ext The extension data.\n\n This function allows a \"prefetch\" of extension data into the\n extension cache. Invoking the function may cause a call to\n xcb_query_extension, but will not block waiting for the\n reply. xcb_get_extension_data will return the prefetched data after\n possibly blocking while it is retrieved."]
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t, ext: *mut xcb_extension_t);
}
extern "C" {
    #[doc = " @brief Access the data returned by the server.\n @param c The connection.\n @return A pointer to an xcb_setup_t structure.\n\n Accessor for the data returned by the server when the xcb_connection_t\n was initialized. This data includes\n - the server's required format for images,\n - a list of available visuals,\n - a list of available screens,\n - the server's maximum request length (in the absence of the\n BIG-REQUESTS extension),\n - and other assorted information.\n\n See the X protocol specification for more details.\n\n The result must not be freed."]
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    #[doc = " @brief Access the file descriptor of the connection.\n @param c The connection.\n @return The file descriptor.\n\n Accessor for the file descriptor that was passed to the\n xcb_connect_to_fd call that returned @p c."]
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Test whether the connection has shut down due to a fatal error.\n @param c The connection.\n @return > 0 if the connection is in an error state; 0 otherwise.\n\n Some errors that occur in the context of an xcb_connection_t\n are unrecoverable. When such an error occurs, the\n connection is shut down and further operations on the\n xcb_connection_t have no effect, but memory will not be freed until\n xcb_disconnect() is called on the xcb_connection_t.\n\n @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.\n @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.\n @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.\n @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.\n @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.\n @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display."]
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Connects to the X server.\n @param fd The file descriptor.\n @param auth_info Authentication data.\n @return A newly allocated xcb_connection_t structure.\n\n Connects to an X server, given the open socket @p fd and the\n xcb_auth_info_t @p auth_info. The file descriptor @p fd is\n bidirectionally connected to an X server. If the connection\n should be unauthenticated, @p auth_info must be @c\n NULL.\n\n Always returns a non-NULL pointer to a xcb_connection_t, even on failure.\n Callers need to use xcb_connection_has_error() to check for failure.\n When finished, use xcb_disconnect() to close the connection and free\n the structure."]
    pub fn xcb_connect_to_fd(
        fd: ::std::os::raw::c_int,
        auth_info: *mut xcb_auth_info_t,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    #[doc = " @brief Closes the connection.\n @param c The connection.\n\n Closes the file descriptor and frees all memory associated with the\n connection @c c. If @p c is @c NULL, nothing is done."]
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    #[doc = " @brief Parses a display string name in the form documented by X(7x).\n @param name The name of the display.\n @param host A pointer to a malloc'd copy of the hostname.\n @param display A pointer to the display number.\n @param screen A pointer to the screen number.\n @return 0 on failure, non 0 otherwise.\n\n Parses the display string name @p display_name in the form\n documented by X(7x). Has no side effects on failure. If\n @p displayname is @c NULL or empty, it uses the environment\n variable DISPLAY. @p hostp is a pointer to a newly allocated string\n that contain the host name. @p displayp is set to the display\n number and @p screenp to the preferred screen number. @p screenp\n can be @c NULL. If @p displayname does not contain a screen number,\n it is set to @c 0."]
    pub fn xcb_parse_display(
        name: *const ::std::os::raw::c_char,
        host: *mut *mut ::std::os::raw::c_char,
        display: *mut ::std::os::raw::c_int,
        screen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Connects to the X server.\n @param displayname The name of the display.\n @param screenp A pointer to a preferred screen number.\n @return A newly allocated xcb_connection_t structure.\n\n Connects to the X server specified by @p displayname. If @p\n displayname is @c NULL, uses the value of the DISPLAY environment\n variable. If a particular screen on that server is preferred, the\n int pointed to by @p screenp (if not @c NULL) will be set to that\n screen; otherwise the screen will be set to 0.\n\n Always returns a non-NULL pointer to a xcb_connection_t, even on failure.\n Callers need to use xcb_connection_has_error() to check for failure.\n When finished, use xcb_disconnect() to close the connection and free\n the structure."]
    pub fn xcb_connect(
        displayname: *const ::std::os::raw::c_char,
        screenp: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    #[doc = " @brief Connects to the X server, using an authorization information.\n @param display The name of the display.\n @param auth The authorization information.\n @param screen A pointer to a preferred screen number.\n @return A newly allocated xcb_connection_t structure.\n\n Connects to the X server specified by @p displayname, using the\n authorization @p auth. If a particular screen on that server is\n preferred, the int pointed to by @p screenp (if not @c NULL) will\n be set to that screen; otherwise @p screenp will be set to 0.\n\n Always returns a non-NULL pointer to a xcb_connection_t, even on failure.\n Callers need to use xcb_connection_has_error() to check for failure.\n When finished, use xcb_disconnect() to close the connection and free\n the structure."]
    pub fn xcb_connect_to_display_with_auth_info(
        display: *const ::std::os::raw::c_char,
        auth: *mut xcb_auth_info_t,
        screen: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    #[doc = " @brief Allocates an XID for a new object.\n @param c The connection.\n @return A newly allocated XID, or -1 on failure.\n\n Allocates an XID for a new object. Typically used just prior to\n various object creation functions, such as xcb_create_window."]
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    #[doc = " @brief Obtain number of bytes read from the connection.\n @param c The connection\n @return Number of bytes read from the server.\n\n Returns cumulative number of bytes received from the connection.\n\n This retrieves the total number of bytes read from this connection,\n to be used for diagnostic/monitoring/informative purposes."]
    pub fn xcb_total_read(c: *mut xcb_connection_t) -> u64;
}
extern "C" {
    #[doc = " @brief Obtain number of bytes written to the connection.\n @param c The connection\n @return Number of bytes written to the server.\n\n Returns cumulative number of bytes sent to the connection.\n\n This retrieves the total number of bytes written to this connection,\n to be used for diagnostic/monitoring/informative purposes."]
    pub fn xcb_total_written(c: *mut xcb_connection_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
